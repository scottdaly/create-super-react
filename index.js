#!/usr/bin/env node
import { execSync } from "node:child_process";
import fs from "node:fs/promises";
import path from "node:path";

const run = (cmd, opts = {}) => execSync(cmd, { stdio: "inherit", ...opts });
const tryRun = (cmd, opts = {}) => {
  try { execSync(cmd, { stdio: "inherit", ...opts }); return true; }
  catch { return false; }
};
const log = (msg = "") => console.log(msg);

// ----------------------------- helpers -------------------------------------

async function ensureTool(cmd, versionArg = "--version", hint = "") {
  try { execSync(`${cmd} ${versionArg}`, { stdio: "ignore" }); }
  catch { console.error(`❌ Missing tool: ${cmd}. ${hint}`); process.exit(1); }
}

async function exists(p) { try { await fs.access(p); return true; } catch { return false; } }
async function dirIsEmpty(dir) { try { const e = await fs.readdir(dir); return e.length === 0; } catch { return true; } }

async function findFile(dir, names) {
  for (const n of names) {
    const full = path.join(dir, n);
    if (await exists(full)) return full;
  }
  return null;
}

/** Add Tailwind plugin import + plugins: [tailwindcss()] to vite.config.* */
function addTailwindToViteConfig(src) {
  let out = src;
  if (!/['"]@tailwindcss\/vite['"]/.test(out)) {
    out = `import tailwindcss from '@tailwindcss/vite'\n` + out;
  }
  const pluginsRe = /plugins\s*:\s*\[([\s\S]*?)\]/m;
  if (pluginsRe.test(out)) {
    if (!/tailwindcss\(\)/.test(out)) {
      out = out.replace(pluginsRe, (m, inner) => {
        const trimmed = inner.trim();
        return `plugins: [${trimmed ? trimmed + ", " : ""}tailwindcss()]`;
      });
    }
    return out;
  }
  const defineRe = /defineConfig\(\s*\{([\s\S]*?)\}\s*\)/m;
  if (defineRe.test(out)) {
    const candidate = out.replace(defineRe, (m, inner) => {
      if (/plugins\s*:/.test(inner)) return m;
      return `defineConfig({\n  plugins: [tailwindcss()],\n${inner}\n})`;
    });
    const count = (candidate.match(/plugins\s*:/g) || []).length;
    if (count <= (out.match(/plugins\s*:/g) || []).length + 1) return candidate;
  }
  if (!/defineConfig/.test(out)) out = `import { defineConfig } from 'vite'\n` + out;
  out += `\n// Added by create-super-react\nexport default defineConfig({ plugins: [tailwindcss()] })\n`;
  return out;
}

/** Add Vite dev proxy to /api → http://localhost:3000 (used when auth enabled) */
function addProxyToViteConfig(src) {
  if (/server\s*:\s*\{[\s\S]*proxy\s*:/.test(src)) return src;
  let out = src;
  const defineRe = /defineConfig\(\s*\{([\s\S]*?)\}\s*\)/m;
  if (defineRe.test(out)) {
    return out.replace(defineRe, (m, inner) => {
      if (/server\s*:\s*\{/.test(inner)) {
        return m.replace(/server\s*:\s*\{([\s\S]*?)\}/m, (sm, sInner) => {
          if (/proxy\s*:/.test(sInner)) return sm;
          const injected = `proxy: { '/api': 'http://localhost:3000' },`;
          return `server: { ${injected}\n${sInner} }`;
        });
      }
      return `defineConfig({\n  server: { proxy: { '/api': 'http://localhost:3000' } },\n${inner}\n})`;
    });
  }
  if (!/defineConfig/.test(out)) out = `import { defineConfig } from 'vite'\n` + out;
  out += `\n// Added by create-super-react\nexport default defineConfig({ server: { proxy: { '/api': 'http://localhost:3000' } } })\n`;
  return out;
}

async function prependIfMissing(filePath, snippet, containsPattern) {
  const has = await exists(filePath);
  let current = has ? await fs.readFile(filePath, "utf8") : "";
  if (!current.includes(containsPattern)) {
    current = snippet + current;
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, current);
  }
}

async function writeClaudeMd(root, withAuth) {
  const project = path.basename(root);

  if (withAuth) {
    const content = `# CLAUDE.md

This project was generated by **create-super-react** (auth preset). It includes a public homepage and an authenticated dashboard, with **local auth (scrypt + secure cookie sessions)**, **CSRF (synchronizer nonce + Origin check)**, and **Google OAuth (PKCE)**.

## Structure
\`\`\`
${project}/
  frontend/  → Vite + React + TypeScript + Tailwind v4 + React Router
  backend/   → Bun + Hono + SQLite (bun:sqlite)
\`\`\`

## Frontend
- React Router routes: \`/\`, \`/login\`, \`/signup\`, \`/dashboard\` (protected)
- \`apiFetch\` helper auto‑adds CSRF headers on unsafe methods and sends cookies
- Tailwind v4 via \`@tailwindcss/vite\` + \`@import "tailwindcss"\` in \`src/index.css\`
- Dev proxy: \`/api\` → \`http://localhost:3000\` so cookie sessions work in dev

## Backend
- SQLite database at \`backend/data.sqlite\`
- Tables:
  - \`users(id, email, password_hash?, created_at)\` (password_hash is NULL for OAuth‑only users)
  - \`sessions(id, user_id, token_hash, csrf_secret, created_at, expires_at, user_agent, ip)\`
  - \`oauth_accounts(provider, provider_user_id, user_id, created_at)\`
  - \`oauth_states(state, code_verifier, nonce, created_at)\` (temporary PKCE state)
- Local auth:
  - Password hashing: **scrypt** (Node crypto) with per‑user salt
  - Session cookie: httpOnly, \`SameSite=Lax\`, \`Secure\` in prod, 30‑day TTL, rotation on login
- CSRF & safety:
  - Synchronizer token with **short‑lived nonce** (10 min) + **Origin/Referer check**
  - CSRF is **skipped only** for \`/api/auth/login\` and \`/api/auth/signup\` (before a session exists)
  - Never mutate state on GET
- Endpoints:
  - POST \`/api/auth/signup\`, POST \`/api/auth/login\`, POST \`/api/auth/logout\`
  - GET \`/api/auth/session\` → \`{ id, email } | null\`
  - GET \`/api/auth/csrf\` → \`{ nonce, token, exp }\`
  - GET \`/api/me\` (protected example)
  - Google OAuth: GET \`/api/auth/google/start\`, GET \`/api/auth/google/callback\`

## Google OAuth Setup (PKCE)
Create \`backend/.env\` (copy from generated \`.env.example\`):
\`\`\`env
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
FRONTEND_ORIGIN=http://localhost:5173
OAUTH_REDIRECT_URI=http://localhost:3000/api/auth/google/callback
\`\`\`
Then add the redirect URI in Google Cloud Console and restart the backend. On the frontend, click **Continue with Google** on \`/login\`.

## Dev commands
\`\`\`bash
# API
cd backend && bun run dev    # http://localhost:3000

# Web
cd ../frontend && npm run dev  # http://localhost:5173
\`\`\`

## Troubleshooting
- **Bad origin** → set \`FRONTEND_ORIGIN\` to your frontend dev/prod origin
- **CSRF missing/invalid/expired** → use \`apiFetch\` or fetch \`/api/auth/csrf\` and send \`X‑CSRF‑Nonce\` + \`X‑CSRF‑Token\`
- **Google not configured** → fill \`.env\` values above
`;
    await fs.writeFile(path.join(root, "CLAUDE.md"), content);
    return;
  }

  // ---- minimal preset (no auth) ----
  const content = `# CLAUDE.md

This project was generated by **create-super-react** using the **minimal preset**. It gives you a clean Vite + React + Tailwind frontend and a small Bun + Hono + SQLite API without authentication.

## Structure
\`\`\`
${project}/
  frontend/  → Vite + React + TypeScript + Tailwind v4
  backend/   → Bun + Hono + SQLite (bun:sqlite)
\`\`\`

## Frontend
- Vite React TS template
- Tailwind v4 via \`@tailwindcss/vite\` + \`@import "tailwindcss"\` in \`src/index.css\`
- No router/auth added by default (you can add React Router later)
- Dev server at \`http://localhost:5173\`

## Backend
- SQLite database at \`backend/data.sqlite\`
- Example routes:
  - GET \`/api/health\`
  - GET \`/api/todos\` → list items
  - POST \`/api/todos\` → create item (JSON: { title: string })
- CORS is enabled for convenience in this preset
- Dev server at \`http://localhost:3000\`

## Dev commands
\`\`\`bash
# API
cd backend && bun run dev    # http://localhost:3000

# Web
cd ../frontend && npm run dev  # http://localhost:5173
\`\`\`

## Next steps
- Add React Router, state management, or your UI kit of choice
- Model your own tables/migrations (consider Drizzle) instead of the sample \`todos\`
- When you're ready for auth, you can:
  - scaffold a new app without \`--minimal\` and copy pieces over, or
  - adapt the auth server from the default preset (local auth + CSRF) into this codebase
`;
  await fs.writeFile(path.join(root, "CLAUDE.md"), content);
}


async function writeBackendEnvExample(backendDir) {
  const env = `# Google OAuth (required for Google login)
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
# Where your frontend runs (dev default)
FRONTEND_ORIGIN=http://localhost:5173
# Callback must be registered in Google console
OAUTH_REDIRECT_URI=http://localhost:3000/api/auth/google/callback
`;
  await fs.writeFile(path.join(backendDir, ".env.example"), env);
}

// ------------------------------- sources -----------------------------------

function backendIndexMinimal() {
  return `
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { Database } from 'bun:sqlite'

const app = new Hono()
app.use('*', cors())

const db = new Database('data.sqlite')
db.run('CREATE TABLE IF NOT EXISTS todos (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, done INTEGER NOT NULL DEFAULT 0)')

app.get('/api/health', (c) => c.json({ ok: true }))
app.get('/api/todos', (c) => {
  const rows = db.query('SELECT id, title, done FROM todos ORDER BY id DESC').all()
  return c.json(rows)
})
app.post('/api/todos', async (c) => {
  const body = await c.req.json().catch(() => null)
  const title = body?.title?.toString().trim()
  if (!title) return c.json({ error: 'title required' }, 400)
  db.query('INSERT INTO todos (title, done) VALUES (?, 0)').run(title)
  return c.json({ ok: true }, 201)
})

export default app
`.trimStart();
}

function backendIndexWithAuthAndGoogle() {
  return `
import { Hono } from 'hono'
import { Database } from 'bun:sqlite'
import { setCookie, getCookie, deleteCookie } from 'hono/cookie'
import { z } from 'zod'
import { randomBytes, scryptSync, timingSafeEqual, createHash, createHmac } from 'node:crypto'

const app = new Hono()
const SESSION_COOKIE = 'sid'
const SESSION_TTL_MS = 1000 * 60 * 60 * 24 * 30 // 30 days
const CSRF_WINDOW_MS = 10 * 60_000 // 10 minutes
const DEV_ALLOWED = process.env.FRONTEND_ORIGIN || 'http://localhost:5173'
const ALLOWED_ORIGINS = new Set([DEV_ALLOWED, 'http://127.0.0.1:5173'])

const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID || ''
const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET || ''
const OAUTH_REDIRECT_URI = process.env.OAUTH_REDIRECT_URI || 'http://localhost:3000/api/auth/google/callback'

const db = new Database('data.sqlite')

// users (password_hash is NULL for OAuth-only accounts)
db.run(\`
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT,
  created_at INTEGER NOT NULL
)\`)

// sessions
db.run(\`
CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  token_hash TEXT UNIQUE NOT NULL,
  csrf_secret TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  expires_at INTEGER NOT NULL,
  user_agent TEXT,
  ip TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
)\`)
db.run('CREATE INDEX IF NOT EXISTS idx_sessions_user ON sessions(user_id)')
db.run('CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at)')

// oauth accounts
db.run(\`
CREATE TABLE IF NOT EXISTS oauth_accounts (
  provider TEXT NOT NULL,
  provider_user_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  PRIMARY KEY(provider, provider_user_id),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
)\`)

// oauth state storage (PKCE + state)
db.run(\`
CREATE TABLE IF NOT EXISTS oauth_states (
  state TEXT PRIMARY KEY,
  code_verifier TEXT NOT NULL,
  nonce TEXT NOT NULL,
  created_at INTEGER NOT NULL
)\`)
db.run('CREATE INDEX IF NOT EXISTS idx_oauth_states_created ON oauth_states(created_at)')

// --- crypto helpers --------------------------------------------------------
const SCRYPT_OPTS = { N: 16384, r: 8, p: 1, maxmem: 128 * 16384 * 8 }
function hashPassword(password) {
  const salt = randomBytes(16)
  const hash = scryptSync(password, salt, 64, SCRYPT_OPTS)
  return 'scrypt$' + ['16384','8','1', salt.toString('base64'), Buffer.from(hash).toString('base64')].join('$')
}
function verifyPassword(password, stored) {
  if (!stored) return false
  const parts = stored.split('$')
  if (parts.length !== 6 || parts[0] !== 'scrypt') return false
  const [ , , r, p, saltB64, hashB64 ] = parts
  const salt = Buffer.from(saltB64, 'base64')
  const expected = Buffer.from(hashB64, 'base64')
  const got = scryptSync(password, salt, expected.length, { N: 16384, r: parseInt(r), p: parseInt(p), maxmem: 128 * 16384 * 8 })
  return timingSafeEqual(got, expected)
}
function newSessionToken() { return randomBytes(32).toString('hex') }
function sha256Hex(str) { return createHash('sha256').update(str).digest('hex') }
const hmac = (secret, data) => createHmac('sha256', secret).update(data).digest('hex')
const now = () => Date.now()
const inProd = () => process.env.NODE_ENV === 'production'
const b64url = (buf) => Buffer.from(buf).toString('base64').replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=+$/,'')
const pkceChallenge = (verifier) => b64url(createHash('sha256').update(verifier).digest())

// --- rate limit (simple in-memory) ----------------------------------------
const hits = new Map()
function rateLimit(key, limit = 10, windowMs = 10 * 60 * 1000) {
  const t = now()
  const rec = hits.get(key) || { count: 0, reset: t + windowMs }
  if (t > rec.reset) { rec.count = 0; rec.reset = t + windowMs }
  rec.count++
  hits.set(key, rec)
  return rec.count <= limit
}

// --- session helpers -------------------------------------------------------
function getSessionRowByTokenHash(tokenHash) {
  return db.query('SELECT s.id as sid, s.user_id as uid, s.csrf_secret as csrf, s.expires_at as exp, u.email as email FROM sessions s JOIN users u ON u.id = s.user_id WHERE s.token_hash = ?').get(tokenHash)
}
function getSession(c) {
  const raw = getCookie(c, SESSION_COOKIE)
  if (!raw) return null
  const row = getSessionRowByTokenHash(sha256Hex(raw))
  if (!row) return null
  if (row.exp < now()) { db.query('DELETE FROM sessions WHERE id = ?').run(row.sid); deleteCookie(c, SESSION_COOKIE); return null }
  return row
}
function setSessionCookie(c, rawToken) {
  setCookie(c, SESSION_COOKIE, rawToken, {
    httpOnly: true,
    sameSite: 'Lax',
    secure: inProd(),
    path: '/',
    maxAge: Math.floor(SESSION_TTL_MS / 1000),
  })
}
function clearSessionCookie(c) { deleteCookie(c, SESSION_COOKIE, { path: '/' }) }

// --- CSRF middleware for unsafe methods -----------------------------------
const UNSAFE = new Set(['POST','PUT','PATCH','DELETE'])
app.use('*', async (c, next) => {
  if (!UNSAFE.has(c.req.method)) return next()
  const origin = c.req.header('origin') || ''
  const referer = c.req.header('referer') || ''
  const fromAllowed = (o) => !!o && Array.from(ALLOWED_ORIGINS).some(a => o.startsWith(a))
  if (origin) { if (!fromAllowed(origin)) return c.json({ error: 'Bad origin' }, 403) }
  else if (referer) { if (!fromAllowed(referer)) return c.json({ error: 'Bad origin' }, 403) }

  const url = new URL(c.req.url); const path = url.pathname
  const skip = path === '/api/auth/login' || path === '/api/auth/signup'
  if (skip) return next()

  const sess = getSession(c)
  if (!sess) return c.json({ error: 'Unauthorized' }, 401)

  const nonce = c.req.header('x-csrf-nonce') || ''
  const token = c.req.header('x-csrf-token') || ''
  if (!nonce || !token) return c.json({ error: 'CSRF token missing' }, 403)
  const expected = hmac(sess.csrf, nonce)
  if (!timingSafeEqual(Buffer.from(token), Buffer.from(expected))) return c.json({ error: 'CSRF token invalid' }, 403)
  const ts = Number((nonce.split(':')[0] || '').trim())
  if (!Number.isFinite(ts) || now() - ts > CSRF_WINDOW_MS) return c.json({ error: 'CSRF token expired' }, 403)
  return next()
})

// --- routes: local auth ----------------------------------------------------
const signupSchema = z.object({ email: z.string().email(), password: z.string().min(8).max(200) })
const loginSchema  = z.object({ email: z.string().email(), password: z.string().min(1) })

app.get('/api/health', (c) => c.json({ ok: true }))

app.get('/api/auth/session', (c) => {
  const sess = getSession(c)
  return c.json(sess ? { id: sess.uid, email: sess.email } : null)
})

app.get('/api/auth/csrf', (c) => {
  const sess = getSession(c)
  if (!sess) return c.json({ error: 'Unauthorized' }, 401)
  const nonce = \`\${now()}:\${randomBytes(8).toString('hex')}\`
  const token = hmac(sess.csrf, nonce)
  const exp = now() + CSRF_WINDOW_MS
  return c.json({ nonce, token, exp })
})

app.post('/api/auth/signup', async (c) => {
  const ip = c.req.header('x-forwarded-for') || 'local'
  if (!rateLimit('signup:' + ip)) return c.json({ error: 'Too many requests' }, 429)
  const body = await c.req.json().catch(() => null)
  const parsed = signupSchema.safeParse(body)
  if (!parsed.success) return c.json({ error: 'Invalid payload' }, 400)
  const email = parsed.data.email.toLowerCase()
  const exists = db.query('SELECT 1 FROM users WHERE email = ?').get(email)
  if (exists) return c.json({ error: 'Account exists' }, 409)

  const id = crypto.randomUUID()
  const password_hash = hashPassword(parsed.data.password)
  const created_at = now()
  db.query('INSERT INTO users (id, email, password_hash, created_at) VALUES (?, ?, ?, ?)').run(id, email, password_hash, created_at)

  const token = newSessionToken()
  const token_hash = sha256Hex(token)
  const csrf_secret = randomBytes(32).toString('hex')
  const ua = c.req.header('user-agent') || ''
  const expires_at = now() + SESSION_TTL_MS
  db.query('INSERT INTO sessions (id, user_id, token_hash, csrf_secret, created_at, expires_at, user_agent, ip) VALUES (?, ?, ?, ?, ?, ?, ?, ?)')
    .run(crypto.randomUUID(), id, token_hash, csrf_secret, now(), expires_at, ua, ip)

  setSessionCookie(c, token)
  return c.json({ id, email })
})

app.post('/api/auth/login', async (c) => {
  const ip = c.req.header('x-forwarded-for') || 'local'
  if (!rateLimit('login:' + ip)) return c.json({ error: 'Too many requests' }, 429)
  const body = await c.req.json().catch(() => null)
  const parsed = loginSchema.safeParse(body)
  if (!parsed.success) return c.json({ error: 'Invalid payload' }, 400)
  const email = parsed.data.email.toLowerCase()
  const user = db.query('SELECT id, email, password_hash FROM users WHERE email = ?').get(email)
  if (!user || !verifyPassword(parsed.data.password, user.password_hash)) {
    return c.json({ error: 'Invalid credentials' }, 401)
  }

  const token = newSessionToken()
  const token_hash = sha256Hex(token)
  const csrf_secret = randomBytes(32).toString('hex')
  const ua = c.req.header('user-agent') || ''
  const expires_at = now() + SESSION_TTL_MS
  db.query('INSERT INTO sessions (id, user_id, token_hash, csrf_secret, created_at, expires_at, user_agent, ip) VALUES (?, ?, ?, ?, ?, ?, ?, ?)')
    .run(crypto.randomUUID(), user.id, token_hash, csrf_secret, now(), expires_at, ua, ip)

  setSessionCookie(c, token)
  return c.json({ id: user.id, email: user.email })
})

app.post('/api/auth/logout', (c) => {
  const raw = getCookie(c, SESSION_COOKIE)
  if (raw) {
    const token_hash = sha256Hex(raw)
    db.query('DELETE FROM sessions WHERE token_hash = ?').run(token_hash)
  }
  clearSessionCookie(c)
  return c.json({ ok: true })
})

app.get('/api/me', (c) => {
  const sess = getSession(c)
  if (!sess) return c.json({ error: 'Unauthorized' }, 401)
  return c.json({ id: sess.uid, email: sess.email })
})

// --- routes: Google OAuth --------------------------------------------------
function q(obj) { return new URLSearchParams(obj).toString() }
function cleanupOldOauthStates() {
  const cutoff = now() - (15 * 60_000)
  db.query('DELETE FROM oauth_states WHERE created_at < ?').run(cutoff)
}

app.get('/api/auth/google/start', (c) => {
  if (!GOOGLE_CLIENT_ID || !GOOGLE_CLIENT_SECRET) {
    return c.json({ error: 'Google OAuth not configured. Set GOOGLE_CLIENT_ID/GOOGLE_CLIENT_SECRET.' }, 500)
  }
  cleanupOldOauthStates()

  const state = b64url(randomBytes(24))
  const code_verifier = b64url(randomBytes(64))
  const nonce = b64url(randomBytes(24))
  const created_at = now()
  db.query('INSERT INTO oauth_states (state, code_verifier, nonce, created_at) VALUES (?, ?, ?, ?)')
    .run(state, code_verifier, nonce, created_at)

  const url = 'https://accounts.google.com/o/oauth2/v2/auth?' + q({
    client_id: GOOGLE_CLIENT_ID,
    redirect_uri: OAUTH_REDIRECT_URI,
    response_type: 'code',
    scope: 'openid email profile',
    include_granted_scopes: 'true',
    access_type: 'offline',
    state,
    nonce,
    code_challenge: pkceChallenge(code_verifier),
    code_challenge_method: 'S256',
    prompt: 'consent'
  })
  return c.redirect(url, 302)
})

app.get('/api/auth/google/callback', async (c) => {
  if (!GOOGLE_CLIENT_ID || !GOOGLE_CLIENT_SECRET) {
    return c.text('Google OAuth not configured.', 500)
  }
  const url = new URL(c.req.url)
  const code = url.searchParams.get('code') || ''
  const state = url.searchParams.get('state') || ''
  if (!code || !state) return c.text('Missing code/state', 400)

  const row = db.query('SELECT code_verifier, nonce, created_at FROM oauth_states WHERE state = ?').get(state)
  if (!row) return c.text('Invalid state', 400)
  // single-use
  db.query('DELETE FROM oauth_states WHERE state = ?').run(state)
  if (now() - row.created_at > 15 * 60_000) return c.text('State expired', 400)

  // Exchange code
  const tokenRes = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: q({
      code,
      client_id: GOOGLE_CLIENT_ID,
      client_secret: GOOGLE_CLIENT_SECRET,
      redirect_uri: OAUTH_REDIRECT_URI,
      grant_type: 'authorization_code',
      code_verifier: row.code_verifier
    })
  })
  if (!tokenRes.ok) {
    const t = await tokenRes.text().catch(() => '')
    return c.text('Token exchange failed: ' + t, 400)
  }
  const tokenJson = await tokenRes.json()
  const access_token = tokenJson.access_token
  if (!access_token) return c.text('No access_token', 400)

  // Fetch userinfo
  const uiRes = await fetch('https://openidconnect.googleapis.com/v1/userinfo', {
    headers: { 'Authorization': 'Bearer ' + access_token }
  })
  if (!uiRes.ok) {
    const t = await uiRes.text().catch(() => '')
    return c.text('Userinfo failed: ' + t, 400)
  }
  const userinfo = await uiRes.json()
  const email = (userinfo.email || '').toLowerCase()
  const sub = userinfo.sub
  const emailVerified = !!userinfo.email_verified
  if (!email || !sub || !emailVerified) {
    return c.text('Google did not return a verified email', 400)
  }

  // Find or create user & link oauth account
  let user = db.query('SELECT id, email FROM users WHERE email = ?').get(email)
  if (!user) {
    const id = crypto.randomUUID()
    db.query('INSERT INTO users (id, email, password_hash, created_at) VALUES (?, ?, NULL, ?)').run(id, email, now())
    user = { id, email }
  }
  // Link account if not linked
  const linked = db.query('SELECT 1 FROM oauth_accounts WHERE provider = ? AND provider_user_id = ?').get('google', sub)
  if (!linked) {
    db.query('INSERT INTO oauth_accounts (provider, provider_user_id, user_id, created_at) VALUES (?, ?, ?, ?)')
      .run('google', sub, user.id, now())
  }

  // Create session
  const token = newSessionToken()
  const token_hash = sha256Hex(token)
  const csrf_secret = randomBytes(32).toString('hex')
  const ua = c.req.header('user-agent') || ''
  const ip = c.req.header('x-forwarded-for') || 'local'
  const expires_at = now() + SESSION_TTL_MS
  db.query('INSERT INTO sessions (id, user_id, token_hash, csrf_secret, created_at, expires_at, user_agent, ip) VALUES (?, ?, ?, ?, ?, ?, ?, ?)')
    .run(crypto.randomUUID(), user.id, token_hash, csrf_secret, now(), expires_at, ua, ip)

  setSessionCookie(c, token)

  // Redirect to frontend
  const dest = (process.env.FRONTEND_ORIGIN || 'http://localhost:5173') + '/dashboard'
  return c.redirect(dest, 302)
})

export default app
`.trimStart();
}

function frontendFilesWithAuth() {
  return {
    "src/http.ts": `
type CsrfBundle = { nonce: string; token: string; exp: number }
let csrfCache: CsrfBundle | null = null

async function fetchCsrf(): Promise<CsrfBundle | null> {
  try {
    const res = await fetch('/api/auth/csrf', { credentials: 'include' })
    if (!res.ok) return null
    return await res.json()
  } catch { return null }
}

async function ensureCsrf(): Promise<CsrfBundle | null> {
  const now = Date.now()
  if (csrfCache && csrfCache.exp - 5000 > now) return csrfCache
  const fresh = await fetchCsrf()
  if (fresh) csrfCache = fresh
  return fresh
}

export async function apiFetch<T = any>(
  input: string,
  opts: { method?: string; body?: any; headers?: Record<string, string>; allowNoCsrf?: boolean } = {}
): Promise<Response> {
  const method = (opts.method || 'GET').toUpperCase()
  const headers: Record<string, string> = { ...(opts.headers || {}) }
  let body: BodyInit | undefined = undefined

  if (opts.body !== undefined && !(opts.body instanceof FormData)) {
    headers['Content-Type'] = headers['Content-Type'] || 'application/json'
    body = JSON.stringify(opts.body)
  } else {
    body = opts.body
  }

  const unsafe = !['GET','HEAD','OPTIONS'].includes(method)
  if (unsafe && !opts.allowNoCsrf) {
    const b = await ensureCsrf()
    if (b) {
      headers['X-CSRF-Nonce'] = b.nonce
      headers['X-CSRF-Token'] = b.token
    }
  }

  return fetch(input, { method, headers, body, credentials: 'include' })
}
`.trimStart(),

    "src/auth.tsx": `
import React, { createContext, useContext, useEffect, useState } from 'react'
import { apiFetch } from './http'

type User = { id: string; email: string } | null
type AuthContextType = {
  user: User
  refresh: () => Promise<void>
  login: (email: string, password: string) => Promise<boolean>
  signup: (email: string, password: string) => Promise<boolean>
  logout: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | null>(null)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User>(null)

  const refresh = async () => {
    const res = await apiFetch('/api/auth/session')
    setUser(res.ok ? await res.json() : null)
  }

  useEffect(() => { refresh() }, [])

  const login = async (email: string, password: string) => {
    const res = await apiFetch('/api/auth/login', {
      method: 'POST',
      body: { email, password },
      allowNoCsrf: true
    })
    if (res.ok) { await refresh(); return true }
    return false
  }

  const signup = async (email: string, password: string) => {
    const res = await apiFetch('/api/auth/signup', {
      method: 'POST',
      body: { email, password },
      allowNoCsrf: true
    })
    if (res.ok) { await refresh(); return true }
    return false
  }

  const logout = async () => {
    await apiFetch('/api/auth/logout', { method: 'POST' })
    await refresh()
  }

  return (
    <AuthContext.Provider value={{ user, refresh, login, signup, logout }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const ctx = useContext(AuthContext)
  if (!ctx) throw new Error('useAuth must be used within AuthProvider')
  return ctx
}
`.trimStart(),

    "src/pages/Home.tsx": `
export default function Home() {
  return (
    <div className="p-6 max-w-xl mx-auto">
      <h1 className="text-2xl font-bold">Welcome</h1>
      <p className="mt-2 text-sm text-gray-600">This is the public homepage.</p>
      <p className="mt-4">Visit <a className="text-blue-600 underline" href="/login">Login</a> or <a className="text-blue-600 underline" href="/signup">Sign up</a>.</p>
    </div>
  )
}
`.trimStart(),

    "src/pages/Login.tsx": `
import { useState } from 'react'
import { useAuth } from '../auth'
import { useNavigate } from 'react-router-dom'

export default function Login() {
  const [email, setEmail] = useState(''); const [password, setPassword] = useState('')
  const [error, setError] = useState(''); const nav = useNavigate()
  const { login } = useAuth()

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    const ok = await login(email, password)
    if (ok) nav('/dashboard'); else setError('Invalid credentials')
  }

  return (
    <div className="p-6 max-w-sm mx-auto">
      <h1 className="text-xl font-bold">Login</h1>
      <form className="mt-4 space-y-3" onSubmit={onSubmit}>
        <input className="border rounded w-full p-2" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)} />
        <input className="border rounded w-full p-2" placeholder="Password" type="password" value={password} onChange={e=>setPassword(e.target.value)} />
        {error && <div className="text-red-600 text-sm">{error}</div>}
        <button className="bg-black text-white px-3 py-2 rounded w-full">Login</button>
      </form>

      <div className="mt-6">
        <button
          className="border px-3 py-2 rounded w-full"
          onClick={() => { window.location.href = '/api/auth/google/start' }}
        >
          Continue with Google
        </button>
      </div>
    </div>
  )
}
`.trimStart(),

    "src/pages/Signup.tsx": `
import { useState } from 'react'
import { useAuth } from '../auth'
import { useNavigate } from 'react-router-dom'

export default function Signup() {
  const [email, setEmail] = useState(''); const [password, setPassword] = useState('')
  const [error, setError] = useState(''); const nav = useNavigate()
  const { signup } = useAuth()

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    const ok = await signup(email, password)
    if (ok) nav('/dashboard'); else setError('Could not create account')
  }

  return (
    <div className="p-6 max-w-sm mx-auto">
      <h1 className="text-xl font-bold">Sign up</h1>
      <form className="mt-4 space-y-3" onSubmit={onSubmit}>
        <input className="border rounded w-full p-2" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)} />
        <input className="border rounded w-full p-2" placeholder="Password (min 8 chars)" type="password" value={password} onChange={e=>setPassword(e.target.value)} />
        {error && <div className="text-red-600 text-sm">{error}</div>}
        <button className="bg-black text-white px-3 py-2 rounded w-full">Create account</button>
      </form>

      <div className="mt-6">
        <button
          className="border px-3 py-2 rounded w-full"
          onClick={() => { window.location.href = '/api/auth/google/start' }}
        >
          Continue with Google
        </button>
      </div>
    </div>
  )
}
`.trimStart(),

    "src/pages/Dashboard.tsx": `
import { useAuth } from '../auth'

export default function Dashboard() {
  const { user, logout } = useAuth()
  return (
    <div className="p-6 max-w-xl mx-auto">
      <h1 className="text-2xl font-bold">Dashboard</h1>
      <p className="mt-2 text-sm text-gray-600">You are logged in as <span className="font-mono">{user?.email}</span>.</p>
      <button className="mt-4 border px-3 py-2 rounded" onClick={logout}>Log out</button>
    </div>
  )
}
`.trimStart(),

    "src/App.tsx": `
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { AuthProvider, useAuth } from './auth'
import Home from './pages/Home'
import Login from './pages/Login'
import Signup from './pages/Signup'
import Dashboard from './pages/Dashboard'

function Protected({ children }: { children: React.ReactNode }) {
  const { user } = useAuth()
  if (user === null) return <Navigate to="/login" replace />
  return <>{children}</>
}

export default function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Home/>} />
          <Route path="/login" element={<Login/>} />
          <Route path="/signup" element={<Signup/>} />
          <Route path="/dashboard" element={<Protected><Dashboard/></Protected>} />
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  )
}
`.trimStart(),
  };
}

// ------------------------------- main --------------------------------------

async function main() {
  const [, , appNameArg, ...rest] = process.argv;
  const appName = appNameArg || "my-app";
  const withAuth = !rest.includes("--minimal"); // default = auth
  const force = rest.includes("--force");

  // Node version check
  const major = parseInt(process.versions.node.split(".")[0], 10);
  if (Number.isFinite(major) && major < 18) {
    console.error(`❌ Node ${process.version} detected. Please use Node >= 18.`);
    process.exit(1);
  }

  await ensureTool("bun", "--version", "Install Bun: https://bun.sh");

  const root = path.resolve(process.cwd(), appName);
  const frontend = path.join(root, "frontend");
  const backend = path.join(root, "backend");

  if (await exists(root) && !(await dirIsEmpty(root)) && !force) {
    console.error(`❌ Target directory "${root}" is not empty. Use --force to scaffold anyway.`);
    process.exit(1);
  }
  await fs.mkdir(root, { recursive: true });

  // -------- FRONTEND --------
  log("📦 Scaffolding frontend with Vite (React + TS)...");
  run(`npm create vite@latest frontend -- --template react-ts`, { cwd: root });

  log("🔧 Installing Tailwind v4 + Vite plugin in frontend...");
  run(`npm i -D tailwindcss @tailwindcss/vite`, { cwd: frontend });

  // Tailwind wiring (+ proxy if auth)
  const viteCfgPath = await findFile(frontend, [
    "vite.config.ts", "vite.config.js", "vite.config.mts", "vite.config.mjs",
  ]);
  if (viteCfgPath) {
    let cfg = await fs.readFile(viteCfgPath, "utf8");
    cfg = addTailwindToViteConfig(cfg);
    if (withAuth) cfg = addProxyToViteConfig(cfg);
    await fs.writeFile(viteCfgPath, cfg);
  } else {
    log("⚠️  Could not find a Vite config to patch. Please add Tailwind (and proxy if using auth) manually.");
  }

  const cssCandidates = ["src/index.css", "src/main.css", "src/style.css"];
  let cssPath = null;
  for (const c of cssCandidates) { const full = path.join(frontend, c); if (await exists(full)) { cssPath = full; break; } }
  if (!cssPath) cssPath = path.join(frontend, "src", "index.css");
  await prependIfMissing(cssPath, `@import "tailwindcss";\n`, '@import "tailwindcss"');

  if (withAuth) {
    log("🧭 Adding React Router + auth pages + CSRF helper + Google button...");
    run(`npm i react-router-dom`, { cwd: frontend });
    const files = frontendFilesWithAuth();
    for (const [rel, content] of Object.entries(files)) {
      const full = path.join(frontend, rel);
      await fs.mkdir(path.dirname(full), { recursive: true });
      await fs.writeFile(full, content);
    }
  }

  // -------- BACKEND --------
  log("📦 Scaffolding backend with Bun + Hono...");
  let ok = tryRun(`bun create hono@latest backend --template bun --install --pm bun`, { cwd: root });
  if (!ok) {
    console.warn("bun create failed; falling back to npm create hono...");
    run(`npm create hono@latest backend -- --template bun --install --pm bun`, { cwd: root });
  }

  if (withAuth) {
    log("🔐 Installing backend deps (zod) and writing auth server with CSRF + Google OAuth...");
    run(`bun add zod`, { cwd: backend });
    await fs.writeFile(path.join(backend, "src", "index.ts"), backendIndexWithAuthAndGoogle());
    await writeBackendEnvExample(backend);
  } else {
    await fs.writeFile(path.join(backend, "src", "index.ts"), backendIndexMinimal());
  }

  try { await fs.appendFile(path.join(backend, ".gitignore"), `\n# SQLite database\n/data.sqlite\n`); } catch {}

  await writeClaudeMd(root, withAuth);

  // -------- Done --------
  log("\n✅ Done!");
  log(`\nNext steps:`);
  log(`  cd ${appName}`);
  log(`  # Terminal 1 (API)`);
  log(`  cd backend && bun run dev    # http://localhost:3000`);
  log(`  # Terminal 2 (Web)`);
  log(`  cd ../frontend && npm run dev   # http://localhost:5173`);
  if (withAuth) {
    log(`\nAuth preset enabled. Configure Google in backend/.env then try the “Continue with Google” button on /login.`);
  } else {
    log(`\nMinimal preset (no auth). Use /api/todos and /api/health for examples.`);
  }
  log("");
}

main().catch((err) => { console.error(err); process.exit(1); });
