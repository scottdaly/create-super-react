#!/usr/bin/env node
import { execSync } from "node:child_process";
import fs from "node:fs/promises";
import path from "node:path";

const run = (cmd, opts = {}) => execSync(cmd, { stdio: "inherit", ...opts });
const tryRun = (cmd, opts = {}) => {
  try { execSync(cmd, { stdio: "inherit", ...opts }); return true; }
  catch { return false; }
};
const log = (msg = "") => console.log(msg);

// ----------------------------- helpers -------------------------------------

async function ensureTool(cmd, versionArg = "--version", hint = "") {
  try {
    execSync(`${cmd} ${versionArg}`, { stdio: "ignore" });
  } catch {
    console.error(`âŒ Missing tool: ${cmd}. ${hint}`);
    process.exit(1);
  }
}

async function exists(p) {
  try { await fs.access(p); return true; } catch { return false; }
}

async function dirIsEmpty(dir) {
  try { const entries = await fs.readdir(dir); return entries.length === 0; }
  catch { return true; } // treat non-existent as empty
}

async function findFile(dir, names) {
  for (const n of names) {
    const full = path.join(dir, n);
    if (await exists(full)) return full;
  }
  return null;
}

/** Add Tailwind plugin import + plugins: [tailwindcss()] to vite.config.* */
function addTailwindToViteConfig(src) {
  let out = src;
  if (!/['"]@tailwindcss\/vite['"]/.test(out)) {
    out = `import tailwindcss from '@tailwindcss/vite'\n` + out;
  }

  const pluginsRe = /plugins\s*:\s*\[([\s\S]*?)\]/m;
  if (pluginsRe.test(out)) {
    if (!/tailwindcss\(\)/.test(out)) {
      out = out.replace(pluginsRe, (m, inner) => {
        const trimmed = inner.trim();
        return `plugins: [${trimmed ? trimmed + ", " : ""}tailwindcss()]`;
      });
    }
    return out;
  }

  const defineRe = /defineConfig\(\s*\{([\s\S]*?)\}\s*\)/m;
  if (defineRe.test(out)) {
    const candidate = out.replace(defineRe, (m, inner) => {
      if (/plugins\s*:/.test(inner)) return m;
      return `defineConfig({\n  plugins: [tailwindcss()],\n${inner}\n})`;
    });
    const count = (candidate.match(/plugins\s*:/g) || []).length;
    if (count <= (out.match(/plugins\s*:/g) || []).length + 1) return candidate;
  }

  if (!/defineConfig/.test(out)) {
    out = `import { defineConfig } from 'vite'\n` + out;
  }
  out += `\n// Added by create-super-react\nexport default defineConfig({ plugins: [tailwindcss()] })\n`;
  return out;
}

/** Add Vite dev proxy to /api â†’ http://localhost:3000 (inside defineConfig) */
function addProxyToViteConfig(src) {
  if (/server\s*:\s*\{[\s\S]*proxy\s*:/.test(src)) return src; // already has a proxy
  let out = src;
  const defineRe = /defineConfig\(\s*\{([\s\S]*?)\}\s*\)/m;
  if (defineRe.test(out)) {
    return out.replace(defineRe, (m, inner) => {
      // If server already exists but no proxy, append proxy
      if (/server\s*:\s*\{/.test(inner)) {
        return m.replace(/server\s*:\s*\{([\s\S]*?)\}/m, (sm, sInner) => {
          if (/proxy\s*:/.test(sInner)) return sm;
          const injected = `proxy: { '/api': 'http://localhost:3000' },`;
          return `server: { ${injected}\n${sInner} }`;
        });
      }
      // Else add a server block near the top
      return `defineConfig({\n  server: { proxy: { '/api': 'http://localhost:3000' } },\n${inner}\n})`;
    });
  }
  // Last resort: create a minimal export
  if (!/defineConfig/.test(out)) out = `import { defineConfig } from 'vite'\n` + out;
  out += `\n// Added by create-super-react\nexport default defineConfig({ server: { proxy: { '/api': 'http://localhost:3000' } } })\n`;
  return out;
}

async function prependIfMissing(filePath, snippet, containsPattern) {
  const has = await exists(filePath);
  let current = has ? await fs.readFile(filePath, "utf8") : "";
  if (!current.includes(containsPattern)) {
    current = snippet + current;
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, current);
  }
}

async function writeClaudeMd(root, withAuth) {
  const content = `# CLAUDE.md

## Purpose
This project is generated by **create-super-react**. It scaffolds a two-folder fullâ€‘stack app.

## Structure

\`\`\`
${path.basename(root)}/
  frontend/  â†’ Vite + React + TypeScript + Tailwind CSS v4${withAuth ? " + React Router (home/login/signup/dashboard)" : ""}
  backend/   â†’ Bun + Hono + SQLite (bun:sqlite)${withAuth ? " + local auth (secure cookies + scrypt)" : ""}
\`\`\`

### Frontend
- Vite React TS template
- Tailwind v4 via \`@tailwindcss/vite\` and \`@import "tailwindcss"\` in \`src/index.css\`.
${withAuth ? "- React Router with routes: `/`, `/login`, `/signup`, `/dashboard` (protected)\n- Vite dev proxy: `/api` â†’ `http://localhost:3000` for cookie-based auth during dev." : ""}

### Backend
- Bun runtime with Hono
- SQLite database at \`backend/data.sqlite\`
${withAuth ? `- Local auth:
  - Password hashing: scrypt (Node crypto) with per-user salt
  - Session cookie: httpOnly, SameSite=Lax, Secure in prod
  - Basic rate limiting for signup/login
  - Routes: POST /api/auth/signup, /login, /logout, GET /api/auth/session
` : `- Example routes:
  - GET /api/health
  - /api/todos (list/create)
`}
### Dev
- API: \`cd backend && bun run dev\` (http://localhost:3000)
- Web: \`cd frontend && npm run dev\` (http://localhost:5173)
`;
  await fs.writeFile(path.join(root, "CLAUDE.md"), content);
}

// ------------------------------- sources -----------------------------------

function backendIndexMinimal() {
  return `
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { Database } from 'bun:sqlite'

const app = new Hono()
app.use('*', cors())

const db = new Database('data.sqlite')
db.run('CREATE TABLE IF NOT EXISTS todos (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, done INTEGER NOT NULL DEFAULT 0)')

app.get('/api/health', (c) => c.json({ ok: true }))
app.get('/api/todos', (c) => {
  const rows = db.query('SELECT id, title, done FROM todos ORDER BY id DESC').all()
  return c.json(rows)
})
app.post('/api/todos', async (c) => {
  const body = await c.req.json().catch(() => null)
  const title = body?.title?.toString().trim()
  if (!title) return c.json({ error: 'title required' }, 400)
  db.query('INSERT INTO todos (title, done) VALUES (?, 0)').run(title)
  return c.json({ ok: true }, 201)
})

export default app
`.trimStart();
}

function backendIndexWithAuth() {
  return `
import { Hono } from 'hono'
import { Database } from 'bun:sqlite'
import { setCookie, getCookie, deleteCookie } from 'hono/cookie'
import { z } from 'zod'
import { randomBytes, scryptSync, timingSafeEqual, createHash } from 'node:crypto'

const app = new Hono()

// --- DB --------------------------------------------------------------------
const db = new Database('data.sqlite')

// users
db.run(\`
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  created_at INTEGER NOT NULL
)\`)

// sessions
db.run(\`
CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  token_hash TEXT UNIQUE NOT NULL,
  created_at INTEGER NOT NULL,
  expires_at INTEGER NOT NULL,
  user_agent TEXT,
  ip TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
)\`)
db.run('CREATE INDEX IF NOT EXISTS idx_sessions_user ON sessions(user_id)')
db.run('CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at)')

// --- crypto helpers --------------------------------------------------------
const SCRYPT_OPTS = { N: 16384, r: 8, p: 1, maxmem: 128 * 16384 * 8 }
const SESSION_COOKIE = 'sid'
const SESSION_TTL_MS = 1000 * 60 * 60 * 24 * 30 // 30 days

function hashPassword(password) {
  const salt = randomBytes(16)
  const hash = scryptSync(password, salt, 64, SCRYPT_OPTS)
  return 'scrypt$' + ['16384','8','1', salt.toString('base64'), Buffer.from(hash).toString('base64')].join('$')
}
function verifyPassword(password, stored) {
  const parts = stored.split('$')
  if (parts.length !== 6 || parts[0] !== 'scrypt') return false
  const [ , , r, p, saltB64, hashB64 ] = parts
  const salt = Buffer.from(saltB64, 'base64')
  const expected = Buffer.from(hashB64, 'base64')
  const got = scryptSync(password, salt, expected.length, { N: 16384, r: parseInt(r), p: parseInt(p), maxmem: 128 * 16384 * 8 })
  return timingSafeEqual(got, expected)
}
function newSessionToken() {
  return randomBytes(32).toString('hex')
}
function sha256Hex(str) {
  return createHash('sha256').update(str).digest('hex')
}
function now() { return Date.now() }
function inProd() { return process.env.NODE_ENV === 'production' }

// --- rate limit (simple in-memory) ----------------------------------------
const hits = new Map() // key -> { count, reset }
function rateLimit(key, limit = 10, windowMs = 10 * 60 * 1000) {
  const t = now()
  const rec = hits.get(key) || { count: 0, reset: t + windowMs }
  if (t > rec.reset) { rec.count = 0; rec.reset = t + windowMs }
  rec.count++
  hits.set(key, rec)
  return rec.count <= limit
}

// --- helpers ---------------------------------------------------------------
async function getSessionUser(c) {
  const raw = getCookie(c, SESSION_COOKIE)
  if (!raw) return null
  const tokenHash = sha256Hex(raw)
  const row = db.query('SELECT u.id as id, u.email as email, s.expires_at as exp FROM sessions s JOIN users u ON u.id = s.user_id WHERE s.token_hash = ?').get(tokenHash)
  if (!row) return null
  if (row.exp < now()) {
    db.query('DELETE FROM sessions WHERE token_hash = ?').run(tokenHash)
    deleteCookie(c, SESSION_COOKIE)
    return null
  }
  return { id: row.id, email: row.email }
}
function setSessionCookie(c, rawToken) {
  setCookie(c, SESSION_COOKIE, rawToken, {
    httpOnly: true,
    sameSite: 'Lax',
    secure: inProd(),
    path: '/',
    maxAge: Math.floor(SESSION_TTL_MS / 1000),
  })
}
function clearSessionCookie(c) {
  deleteCookie(c, SESSION_COOKIE, { path: '/' })
}

// --- routes ----------------------------------------------------------------
const signupSchema = z.object({ email: z.string().email(), password: z.string().min(8).max(200) })
const loginSchema  = z.object({ email: z.string().email(), password: z.string().min(1) })

app.get('/api/health', (c) => c.json({ ok: true }))

app.get('/api/auth/session', async (c) => {
  const user = await getSessionUser(c)
  return c.json(user)
})

app.post('/api/auth/signup', async (c) => {
  const ip = c.req.header('x-forwarded-for') || 'local'
  if (!rateLimit('signup:' + ip)) return c.json({ error: 'Too many requests' }, 429)

  const body = await c.req.json().catch(() => null)
  const parsed = signupSchema.safeParse(body)
  if (!parsed.success) return c.json({ error: 'Invalid payload' }, 400)

  const email = parsed.data.email.toLowerCase()
  const existing = db.query('SELECT 1 FROM users WHERE email = ?').get(email)
  if (existing) return c.json({ error: 'Account exists' }, 409)

  const id = crypto.randomUUID()
  const password_hash = hashPassword(parsed.data.password)
  const created_at = now()
  db.query('INSERT INTO users (id, email, password_hash, created_at) VALUES (?, ?, ?, ?)').run(id, email, password_hash, created_at)

  // session
  const token = newSessionToken()
  const token_hash = sha256Hex(token)
  const ua = c.req.header('user-agent') || ''
  const expires_at = now() + SESSION_TTL_MS
  db.query('INSERT INTO sessions (id, user_id, token_hash, created_at, expires_at, user_agent, ip) VALUES (?, ?, ?, ?, ?, ?, ?)')
    .run(crypto.randomUUID(), id, token_hash, now(), expires_at, ua, ip)

  setSessionCookie(c, token)
  return c.json({ id, email })
})

app.post('/api/auth/login', async (c) => {
  const ip = c.req.header('x-forwarded-for') || 'local'
  if (!rateLimit('login:' + ip)) return c.json({ error: 'Too many requests' }, 429)

  const body = await c.req.json().catch(() => null)
  const parsed = loginSchema.safeParse(body)
  if (!parsed.success) return c.json({ error: 'Invalid payload' }, 400)

  const email = parsed.data.email.toLowerCase()
  const user = db.query('SELECT id, password_hash FROM users WHERE email = ?').get(email)
  if (!user || !verifyPassword(parsed.data.password, user.password_hash)) {
    // Deliberately generic to avoid account enumeration timing/channel
    return c.json({ error: 'Invalid credentials' }, 401)
  }

  // create new session (rotation)
  const token = newSessionToken()
  const token_hash = sha256Hex(token)
  const ua = c.req.header('user-agent') || ''
  const expires_at = now() + SESSION_TTL_MS
  db.query('INSERT INTO sessions (id, user_id, token_hash, created_at, expires_at, user_agent, ip) VALUES (?, ?, ?, ?, ?, ?, ?)')
    .run(crypto.randomUUID(), user.id, token_hash, now(), expires_at, ua, ip)

  setSessionCookie(c, token)
  return c.json({ id: user.id, email })
})

app.post('/api/auth/logout', async (c) => {
  const raw = getCookie(c, SESSION_COOKIE)
  if (raw) {
    const token_hash = sha256Hex(raw)
    db.query('DELETE FROM sessions WHERE token_hash = ?').run(token_hash)
  }
  clearSessionCookie(c)
  return c.json({ ok: true })
})

// Example protected endpoint
app.get('/api/me', async (c) => {
  const user = await getSessionUser(c)
  if (!user) return c.json({ error: 'Unauthorized' }, 401)
  return c.json(user)
})

export default app
`.trimStart();
}

function frontendFilesWithAuth() {
  return {
    "src/auth.tsx": `
import React, { createContext, useContext, useEffect, useState } from 'react'

type User = { id: string; email: string } | null
type AuthContextType = {
  user: User
  refresh: () => Promise<void>
  login: (email: string, password: string) => Promise<boolean>
  signup: (email: string, password: string) => Promise<boolean>
  logout: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | null>(null)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User>(null)

  const refresh = async () => {
    const res = await fetch('/api/auth/session', { credentials: 'include' })
    setUser(res.ok ? await res.json() : null)
  }

  useEffect(() => { refresh() }, [])

  const login = async (email: string, password: string) => {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ email, password })
    })
    if (res.ok) { await refresh(); return true }
    return false
  }

  const signup = async (email: string, password: string) => {
    const res = await fetch('/api/auth/signup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ email, password })
    })
    if (res.ok) { await refresh(); return true }
    return false
  }

  const logout = async () => {
    await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' })
    await refresh()
  }

  return (
    <AuthContext.Provider value={{ user, refresh, login, signup, logout }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const ctx = useContext(AuthContext)
  if (!ctx) throw new Error('useAuth must be used within AuthProvider')
  return ctx
}
`.trimStart(),
    "src/pages/Home.tsx": `
export default function Home() {
  return (
    <div className="p-6 max-w-xl mx-auto">
      <h1 className="text-2xl font-bold">Welcome</h1>
      <p className="mt-2 text-sm text-gray-600">This is the public homepage.</p>
      <p className="mt-4">Visit <a className="text-blue-600 underline" href="/login">Login</a> or <a className="text-blue-600 underline" href="/signup">Sign up</a>.</p>
    </div>
  )
}
`.trimStart(),
    "src/pages/Login.tsx": `
import { useState } from 'react'
import { useAuth } from '../auth'
import { useNavigate } from 'react-router-dom'

export default function Login() {
  const [email, setEmail] = useState(''); const [password, setPassword] = useState('')
  const [error, setError] = useState(''); const nav = useNavigate()
  const { login } = useAuth()

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    const ok = await login(email, password)
    if (ok) nav('/dashboard'); else setError('Invalid credentials')
  }

  return (
    <div className="p-6 max-w-sm mx-auto">
      <h1 className="text-xl font-bold">Login</h1>
      <form className="mt-4 space-y-3" onSubmit={onSubmit}>
        <input className="border rounded w-full p-2" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)} />
        <input className="border rounded w-full p-2" placeholder="Password" type="password" value={password} onChange={e=>setPassword(e.target.value)} />
        {error && <div className="text-red-600 text-sm">{error}</div>}
        <button className="bg-black text-white px-3 py-2 rounded w-full">Login</button>
      </form>
    </div>
  )
}
`.trimStart(),
    "src/pages/Signup.tsx": `
import { useState } from 'react'
import { useAuth } from '../auth'
import { useNavigate } from 'react-router-dom'

export default function Signup() {
  const [email, setEmail] = useState(''); const [password, setPassword] = useState('')
  const [error, setError] = useState(''); const nav = useNavigate()
  const { signup } = useAuth()

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    const ok = await signup(email, password)
    if (ok) nav('/dashboard'); else setError('Could not create account')
  }

  return (
    <div className="p-6 max-w-sm mx-auto">
      <h1 className="text-xl font-bold">Sign up</h1>
      <form className="mt-4 space-y-3" onSubmit={onSubmit}>
        <input className="border rounded w-full p-2" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)} />
        <input className="border rounded w-full p-2" placeholder="Password (min 8 chars)" type="password" value={password} onChange={e=>setPassword(e.target.value)} />
        {error && <div className="text-red-600 text-sm">{error}</div>}
        <button className="bg-black text-white px-3 py-2 rounded w-full">Create account</button>
      </form>
    </div>
  )
}
`.trimStart(),
    "src/pages/Dashboard.tsx": `
import { useAuth } from '../auth'

export default function Dashboard() {
  const { user, logout } = useAuth()
  return (
    <div className="p-6 max-w-xl mx-auto">
      <h1 className="text-2xl font-bold">Dashboard</h1>
      <p className="mt-2 text-sm text-gray-600">You are logged in as <span className="font-mono">{user?.email}</span>.</p>
      <button className="mt-4 border px-3 py-2 rounded" onClick={logout}>Log out</button>
    </div>
  )
}
`.trimStart(),
    "src/App.tsx": `
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { AuthProvider, useAuth } from './auth'
import Home from './pages/Home'
import Login from './pages/Login'
import Signup from './pages/Signup'
import Dashboard from './pages/Dashboard'

function Protected({ children }: { children: React.ReactNode }) {
  const { user } = useAuth()
  if (user === null) return <Navigate to="/login" replace />
  return <>{children}</>
}

export default function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Home/>} />
          <Route path="/login" element={<Login/>} />
          <Route path="/signup" element={<Signup/>} />
          <Route path="/dashboard" element={<Protected><Dashboard/></Protected>} />
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  )
}
`.trimStart(),
  };
}

// ------------------------------- main --------------------------------------

async function main() {
  const [, , appNameArg, ...rest] = process.argv;
  const appName = appNameArg || "my-app";
  const withAuth = !rest.includes("--minimal"); // default = auth
  const force = rest.includes("--force");

  // Node version check
  const major = parseInt(process.versions.node.split(".")[0], 10);
  if (Number.isFinite(major) && major < 18) {
    console.error(`âŒ Node ${process.version} detected. Please use Node >= 18.`);
    process.exit(1);
  }

  await ensureTool("bun", "--version", "Install Bun: https://bun.sh");

  const root = path.resolve(process.cwd(), appName);
  const frontend = path.join(root, "frontend");
  const backend = path.join(root, "backend");

  // prevent clobber unless --force
  if (await exists(root) && !(await dirIsEmpty(root)) && !force) {
    console.error(`âŒ Target directory "${root}" is not empty. Use --force to scaffold anyway.`);
    process.exit(1);
  }
  await fs.mkdir(root, { recursive: true });

  // -------- FRONTEND --------
  log("ðŸ“¦ Scaffolding frontend with Vite (React + TS)...");
  run(`npm create vite@latest frontend -- --template react-ts`, { cwd: root });

  log("ðŸ”§ Installing Tailwind v4 + Vite plugin in frontend...");
  run(`npm i -D tailwindcss @tailwindcss/vite`, { cwd: frontend });

  // Tailwind wiring
  const viteCfgPath = await findFile(frontend, [
    "vite.config.ts",
    "vite.config.js",
    "vite.config.mts",
    "vite.config.mjs",
  ]);
  if (viteCfgPath) {
    let cfg = await fs.readFile(viteCfgPath, "utf8");
    cfg = addTailwindToViteConfig(cfg);
    if (withAuth) cfg = addProxyToViteConfig(cfg);
    await fs.writeFile(viteCfgPath, cfg);
  } else {
    log("âš ï¸  Could not find a Vite config to patch. Please add Tailwind (and proxy if using auth) manually.");
  }

  // Ensure Tailwind import exists in CSS
  const cssCandidates = ["src/index.css", "src/main.css", "src/style.css"];
  let cssPath = null;
  for (const c of cssCandidates) {
    const full = path.join(frontend, c);
    if (await exists(full)) { cssPath = full; break; }
  }
  if (!cssPath) cssPath = path.join(frontend, "src", "index.css");
  await prependIfMissing(cssPath, `@import "tailwindcss";\n`, '@import "tailwindcss"');

  // Add router & pages for auth preset
  if (withAuth) {
    log("ðŸ§­ Adding React Router + auth pages...");
    run(`npm i react-router-dom`, { cwd: frontend });

    const files = frontendFilesWithAuth();
    for (const [rel, content] of Object.entries(files)) {
      const full = path.join(frontend, rel);
      await fs.mkdir(path.dirname(full), { recursive: true });
      await fs.writeFile(full, content);
    }
  }

  // -------- BACKEND --------
  log("ðŸ“¦ Scaffolding backend with Bun + Hono...");
  let ok = tryRun(`bun create hono@latest backend --template bun --install --pm bun`, { cwd: root });
  if (!ok) {
    console.warn("bun create failed; falling back to npm create hono...");
    run(`npm create hono@latest backend -- --template bun --install --pm bun`, { cwd: root });
  }

  if (withAuth) {
    log("ðŸ” Installing backend deps (zod) and writing auth server...");
    run(`bun add zod`, { cwd: backend });
    await fs.writeFile(path.join(backend, "src", "index.ts"), backendIndexWithAuth());
  } else {
    await fs.writeFile(path.join(backend, "src", "index.ts"), backendIndexMinimal());
  }

  // Ignore DB file
  try {
    await fs.appendFile(path.join(backend, ".gitignore"), `\n# SQLite database\n/data.sqlite\n`);
  } catch {}

  // Docs
  await writeClaudeMd(root, withAuth);

  // -------- Done --------
  log("\nâœ… Done!");
  log(`\nNext steps:`);
  log(`  cd ${appName}`);
  log(`  # Terminal 1 (API)`);
  log(`  cd backend && bun run dev    # http://localhost:3000`);
  log(`  # Terminal 2 (Web)`);
  log(`  cd ../frontend && npm run dev   # http://localhost:5173`);
  if (withAuth) {
    log(`\nAuth preset enabled. Use /login and /signup, then /dashboard (protected).`);
  } else {
    log(`\nMinimal preset (no auth). Use /api/todos and /api/health for examples.`);
  }
  log("");
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
