#!/usr/bin/env node
import { execSync } from "node:child_process";
import fs from "node:fs/promises";
import path from "node:path";

const run = (cmd, opts = {}) => execSync(cmd, { stdio: "inherit", ...opts });
const tryRun = (cmd, opts = {}) => {
  try { execSync(cmd, { stdio: "inherit", ...opts }); return true; }
  catch { return false; }
};
const log = (msg = "") => console.log(msg);

// ----------------------------- helpers -------------------------------------

async function ensureTool(cmd, versionArg = "--version", hint = "") {
  try { execSync(`${cmd} ${versionArg}`, { stdio: "ignore" }); }
  catch { console.error(`❌ Missing tool: ${cmd}. ${hint}`); process.exit(1); }
}

async function exists(p) { try { await fs.access(p); return true; } catch { return false; } }
async function dirIsEmpty(dir) { try { const e = await fs.readdir(dir); return e.length === 0; } catch { return true; } }

async function findFile(dir, names) {
  for (const n of names) {
    const full = path.join(dir, n);
    if (await exists(full)) return full;
  }
  return null;
}

/** Add Tailwind plugin import + plugins: [tailwindcss()] to vite.config.* */
function addTailwindToViteConfig(src) {
  let out = src;
  if (!/['"]@tailwindcss\/vite['"]/.test(out)) {
    out = `import tailwindcss from '@tailwindcss/vite'\n` + out;
  }
  const pluginsRe = /plugins\s*:\s*\[([\s\S]*?)\]/m;
  if (pluginsRe.test(out)) {
    if (!/tailwindcss\(\)/.test(out)) {
      out = out.replace(pluginsRe, (m, inner) => {
        const trimmed = inner.trim();
        return `plugins: [${trimmed ? trimmed + ", " : ""}tailwindcss()]`;
      });
    }
    return out;
  }
  const defineRe = /defineConfig\(\s*\{([\s\S]*?)\}\s*\)/m;
  if (defineRe.test(out)) {
    const candidate = out.replace(defineRe, (m, inner) => {
      if (/plugins\s*:/.test(inner)) return m;
      return `defineConfig({\n  plugins: [tailwindcss()],\n${inner}\n})`;
    });
    const count = (candidate.match(/plugins\s*:/g) || []).length;
    if (count <= (out.match(/plugins\s*:/g) || []).length + 1) return candidate;
  }
  if (!/defineConfig/.test(out)) out = `import { defineConfig } from 'vite'\n` + out;
  out += `\n// Added by create-super-react\nexport default defineConfig({ plugins: [tailwindcss()] })\n`;
  return out;
}

/** Add Vite dev proxy to /api → http://localhost:3000 (used when auth enabled) */
function addProxyToViteConfig(src) {
  if (/server\s*:\s*\{[\s\S]*proxy\s*:/.test(src)) return src;
  let out = src;
  const defineRe = /defineConfig\(\s*\{([\s\S]*?)\}\s*\)/m;
  if (defineRe.test(out)) {
    return out.replace(defineRe, (m, inner) => {
      if (/server\s*:\s*\{/.test(inner)) {
        return m.replace(/server\s*:\s*\{([\s\S]*?)\}/m, (sm, sInner) => {
          if (/proxy\s*:/.test(sInner)) return sm;
          const injected = `proxy: { '/api': 'http://localhost:3000' },`;
          return `server: { ${injected}\n${sInner} }`;
        });
      }
      return `defineConfig({\n  server: { proxy: { '/api': 'http://localhost:3000' } },\n${inner}\n})`;
    });
  }
  if (!/defineConfig/.test(out)) out = `import { defineConfig } from 'vite'\n` + out;
  out += `\n// Added by create-super-react\nexport default defineConfig({ server: { proxy: { '/api': 'http://localhost:3000' } } })\n`;
  return out;
}

async function prependIfMissing(filePath, snippet, containsPattern) {
  const has = await exists(filePath);
  let current = has ? await fs.readFile(filePath, "utf8") : "";
  if (!current.includes(containsPattern)) {
    current = snippet + current;
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, current);
  }
}

async function writeClaudeMd(root, withAuth) {
  const project = path.basename(root);

  if (withAuth) {
    const content = `# CLAUDE.md

This project was generated by **create-super-react** (auth preset). It includes a public homepage and an authenticated dashboard, with **local auth (scrypt + secure cookie sessions)**, **CSRF (synchronizer nonce + Origin check)**, and **Google OAuth (PKCE)**.

## Structure
\`\`\`
${project}/
  frontend/  → Vite + React + TypeScript + Tailwind v4 + React Router
  backend/   → Bun + Hono + SQLite (bun:sqlite)
\`\`\`

## Frontend
- React Router routes: \`/\`, \`/login\`, \`/signup\`, \`/dashboard\` (protected)
- \`apiFetch\` helper auto‑adds CSRF headers on unsafe methods and sends cookies
- Tailwind v4 via \`@tailwindcss/vite\` + \`@import "tailwindcss"\` in \`src/index.css\`
- Dev proxy: \`/api\` → \`http://localhost:3000\` so cookie sessions work in dev

## Backend
- SQLite database at \`backend/data.sqlite\`
- Tables:
  - \`users(id, email, password_hash?, created_at)\` (password_hash is NULL for OAuth‑only users)
  - \`sessions(id, user_id, token_hash, csrf_secret, created_at, expires_at, user_agent, ip)\`
  - \`oauth_accounts(provider, provider_user_id, user_id, created_at)\`
  - \`oauth_states(state, code_verifier, nonce, created_at)\` (temporary PKCE state)
- Local auth:
  - Password hashing: **scrypt** (Node crypto) with per‑user salt
  - Session cookie: httpOnly, \`SameSite=Lax\`, \`Secure\` in prod, 30‑day TTL, rotation on login
- CSRF & safety:
  - Synchronizer token with **short‑lived nonce** (10 min) + **Origin/Referer check**
  - CSRF is **skipped only** for \`/api/auth/login\` and \`/api/auth/signup\` (before a session exists)
  - Never mutate state on GET
- Endpoints:
  - POST \`/api/auth/signup\`, POST \`/api/auth/login\`, POST \`/api/auth/logout\`
  - GET \`/api/auth/session\` → \`{ id, email } | null\`
  - GET \`/api/auth/csrf\` → \`{ nonce, token, exp }\`
  - GET \`/api/me\` (protected example)
  - Google OAuth: GET \`/api/auth/google/start\`, GET \`/api/auth/google/callback\`

## Google OAuth Setup (PKCE)
Create \`backend/.env\` (copy from generated \`.env.example\`):
\`\`\`env
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
FRONTEND_ORIGIN=http://localhost:5173
OAUTH_REDIRECT_URI=http://localhost:3000/api/auth/google/callback
\`\`\`
Then add the redirect URI in Google Cloud Console and restart the backend. On the frontend, click **Continue with Google** on \`/login\`.

## Dev commands
\`\`\`bash
# API
cd backend && bun run dev    # http://localhost:3000

# Web
cd ../frontend && npm run dev  # http://localhost:5173
\`\`\`

## Troubleshooting
- **Bad origin** → set \`FRONTEND_ORIGIN\` to your frontend dev/prod origin
- **CSRF missing/invalid/expired** → use \`apiFetch\` or fetch \`/api/auth/csrf\` and send \`X‑CSRF‑Nonce\` + \`X‑CSRF‑Token\`
- **Google not configured** → fill \`.env\` values above
`;
    await fs.writeFile(path.join(root, "CLAUDE.md"), content);
    return;
  }

  // ---- minimal preset (no auth) ----
  const content = `# CLAUDE.md

This project was generated by **create-super-react** using the **minimal preset**. It gives you a clean Vite + React + Tailwind frontend and a small Bun + Hono + SQLite API without authentication.

## Structure
\`\`\`
${project}/
  frontend/  → Vite + React + TypeScript + Tailwind v4
  backend/   → Bun + Hono + SQLite (bun:sqlite)
\`\`\`

## Frontend
- Vite React TS template
- Tailwind v4 via \`@tailwindcss/vite\` + \`@import "tailwindcss"\` in \`src/index.css\`
- No router/auth added by default (you can add React Router later)
- Dev server at \`http://localhost:5173\`

## Backend
- SQLite database at \`backend/data.sqlite\`
- Example routes:
  - GET \`/api/health\`
  - GET \`/api/todos\` → list items
  - POST \`/api/todos\` → create item (JSON: { title: string })
- CORS is enabled for convenience in this preset
- Dev server at \`http://localhost:3000\`

## Dev commands
\`\`\`bash
# API
cd backend && bun run dev    # http://localhost:3000

# Web
cd ../frontend && npm run dev  # http://localhost:5173
\`\`\`

## Next steps
- Add React Router, state management, or your UI kit of choice
- Model your own tables/migrations (consider Drizzle) instead of the sample \`todos\`
- When you're ready for auth, you can:
  - scaffold a new app without \`--minimal\` and copy pieces over, or
  - adapt the auth server from the default preset (local auth + CSRF) into this codebase
`;
  await fs.writeFile(path.join(root, "CLAUDE.md"), content);
}


async function writeBackendEnvExample(backendDir) {
  const env = `# Google OAuth (required for Google login)
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
# Where your frontend runs (dev default)
FRONTEND_ORIGIN=http://localhost:5173
# Callback must be registered in Google console
OAUTH_REDIRECT_URI=http://localhost:3000/api/auth/google/callback
`;
  await fs.writeFile(path.join(backendDir, ".env.example"), env);
}

// ------------------------------- sources -----------------------------------

function backendIndexMinimal() {
  return `
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { Database } from 'bun:sqlite'

const app = new Hono()
app.use('*', cors())

const db = new Database('data.sqlite')
db.run('CREATE TABLE IF NOT EXISTS todos (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, done INTEGER NOT NULL DEFAULT 0)')

app.get('/api/health', (c) => c.json({ ok: true }))
app.get('/api/todos', (c) => {
  const rows = db.query('SELECT id, title, done FROM todos ORDER BY id DESC').all()
  return c.json(rows)
})
app.post('/api/todos', async (c) => {
  const body = await c.req.json().catch(() => null)
  const title = body?.title?.toString().trim()
  if (!title) return c.json({ error: 'title required' }, 400)
  db.query('INSERT INTO todos (title, done) VALUES (?, 0)').run(title)
  return c.json({ ok: true }, 201)
})

export default app
`.trimStart();
}

function backendIndexWithAuthAndGoogle() {
  return `
import { Hono } from 'hono'
import { Database } from 'bun:sqlite'
import { setCookie, getCookie, deleteCookie } from 'hono/cookie'
import { z } from 'zod'
import { randomBytes, scryptSync, timingSafeEqual, createHash, createHmac } from 'node:crypto'

const app = new Hono()
const SESSION_COOKIE = 'sid'
const SESSION_TTL_MS = 1000 * 60 * 60 * 24 * 30 // 30 days
const CSRF_WINDOW_MS = 10 * 60_000 // 10 minutes
const DEV_ALLOWED = process.env.FRONTEND_ORIGIN || 'http://localhost:5173'
const ALLOWED_ORIGINS = new Set([DEV_ALLOWED, 'http://127.0.0.1:5173'])

const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID || ''
const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET || ''
const OAUTH_REDIRECT_URI = process.env.OAUTH_REDIRECT_URI || 'http://localhost:3000/api/auth/google/callback'

const db = new Database('data.sqlite')

// users (password_hash is NULL for OAuth-only accounts)
db.run(\`
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT,
  created_at INTEGER NOT NULL
)\`)

// sessions
db.run(\`
CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  token_hash TEXT UNIQUE NOT NULL,
  csrf_secret TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  expires_at INTEGER NOT NULL,
  user_agent TEXT,
  ip TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
)\`)
db.run('CREATE INDEX IF NOT EXISTS idx_sessions_user ON sessions(user_id)')
db.run('CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at)')

// oauth accounts
db.run(\`
CREATE TABLE IF NOT EXISTS oauth_accounts (
  provider TEXT NOT NULL,
  provider_user_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  PRIMARY KEY(provider, provider_user_id),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
)\`)

// oauth state storage (PKCE + state)
db.run(\`
CREATE TABLE IF NOT EXISTS oauth_states (
  state TEXT PRIMARY KEY,
  code_verifier TEXT NOT NULL,
  nonce TEXT NOT NULL,
  created_at INTEGER NOT NULL
)\`)
db.run('CREATE INDEX IF NOT EXISTS idx_oauth_states_created ON oauth_states(created_at)')

// --- crypto helpers --------------------------------------------------------
const SCRYPT_OPTS = { N: 16384, r: 8, p: 1, maxmem: 64 * 1024 * 1024 }
function hashPassword(password) {
  const salt = randomBytes(16)
  const hash = scryptSync(password, salt, 64, SCRYPT_OPTS)
  return 'scrypt$' + ['16384','8','1', salt.toString('base64'), Buffer.from(hash).toString('base64')].join('$')
}
function verifyPassword(password, stored) {
  if (!stored) return false
  const parts = stored.split('$')
  if (parts.length !== 6 || parts[0] !== 'scrypt') return false
  const [ , Nstr, rStr, pStr, saltB64, hashB64 ] = parts
  const N = parseInt(Nstr, 10), r = parseInt(rStr, 10), p = parseInt(pStr, 10)
  const salt = Buffer.from(saltB64, 'base64')
  const expected = Buffer.from(hashB64, 'base64')
  const got = scryptSync(password, salt, expected.length, { N, r, p, maxmem: 64 * 1024 * 1024 })
  return timingSafeEqual(got, expected)
}
function newSessionToken() { return randomBytes(32).toString('hex') }
function sha256Hex(str) { return createHash('sha256').update(str).digest('hex') }
const hmac = (secret, data) => createHmac('sha256', secret).update(data).digest('hex')
const now = () => Date.now()
const inProd = () => process.env.NODE_ENV === 'production'
const b64url = (buf) => Buffer.from(buf).toString('base64').replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=+$/,'')
const pkceChallenge = (verifier) => b64url(createHash('sha256').update(verifier).digest())

// --- rate limit (simple in-memory) ----------------------------------------
const hits = new Map()
function rateLimit(key, limit = 10, windowMs = 10 * 60 * 1000) {
  const t = now()
  const rec = hits.get(key) || { count: 0, reset: t + windowMs }
  if (t > rec.reset) { rec.count = 0; rec.reset = t + windowMs }
  rec.count++
  hits.set(key, rec)
  return rec.count <= limit
}

// --- session helpers -------------------------------------------------------
function getSessionRowByTokenHash(tokenHash) {
  return db.query('SELECT s.id as sid, s.user_id as uid, s.csrf_secret as csrf, s.expires_at as exp, u.email as email FROM sessions s JOIN users u ON u.id = s.user_id WHERE s.token_hash = ?').get(tokenHash)
}
function getSession(c) {
  const raw = getCookie(c, SESSION_COOKIE)
  if (!raw) return null
  const row = getSessionRowByTokenHash(sha256Hex(raw))
  if (!row) return null
  if (row.exp < now()) { db.query('DELETE FROM sessions WHERE id = ?').run(row.sid); deleteCookie(c, SESSION_COOKIE); return null }
  return row
}
function setSessionCookie(c, rawToken) {
  setCookie(c, SESSION_COOKIE, rawToken, {
    httpOnly: true,
    sameSite: 'Lax',
    secure: inProd(),
    path: '/',
    maxAge: Math.floor(SESSION_TTL_MS / 1000),
  })
}
function clearSessionCookie(c) { deleteCookie(c, SESSION_COOKIE, { path: '/' }) }

// --- CSRF middleware for unsafe methods -----------------------------------
const UNSAFE = new Set(['POST','PUT','PATCH','DELETE'])
app.use('*', async (c, next) => {
  if (!UNSAFE.has(c.req.method)) return next()
  const origin = c.req.header('origin') || ''
  const referer = c.req.header('referer') || ''
  const fromAllowed = (o) => !!o && Array.from(ALLOWED_ORIGINS).some(a => o.startsWith(a))
  if (origin) { if (!fromAllowed(origin)) return c.json({ error: 'Bad origin' }, 403) }
  else if (referer) { if (!fromAllowed(referer)) return c.json({ error: 'Bad origin' }, 403) }

  const url = new URL(c.req.url); const path = url.pathname
  const skip = path === '/api/auth/login' || path === '/api/auth/signup'
  if (skip) return next()

  const sess = getSession(c)
  if (!sess) return c.json({ error: 'Unauthorized' }, 401)

  const nonce = c.req.header('x-csrf-nonce') || ''
  const token = c.req.header('x-csrf-token') || ''
  if (!nonce || !token) return c.json({ error: 'CSRF token missing' }, 403)
  const expected = hmac(sess.csrf, nonce)
  if (!timingSafeEqual(Buffer.from(token), Buffer.from(expected))) return c.json({ error: 'CSRF token invalid' }, 403)
  const ts = Number((nonce.split(':')[0] || '').trim())
  if (!Number.isFinite(ts) || now() - ts > CSRF_WINDOW_MS) return c.json({ error: 'CSRF token expired' }, 403)
  return next()
})

// --- routes: local auth ----------------------------------------------------
const signupSchema = z.object({ email: z.string().email(), password: z.string().min(8).max(200) })
const loginSchema  = z.object({ email: z.string().email(), password: z.string().min(1) })

app.get('/api/health', (c) => c.json({ ok: true }))

app.get('/api/auth/session', (c) => {
  const sess = getSession(c)
  return c.json(sess ? { id: sess.uid, email: sess.email } : null)
})

app.get('/api/auth/csrf', (c) => {
  const sess = getSession(c)
  if (!sess) return c.json({ error: 'Unauthorized' }, 401)
  const nonce = \`\${now()}:\${randomBytes(8).toString('hex')}\`
  const token = hmac(sess.csrf, nonce)
  const exp = now() + CSRF_WINDOW_MS
  return c.json({ nonce, token, exp })
})

app.post('/api/auth/signup', async (c) => {
  const ip = c.req.header('x-forwarded-for') || 'local'
  if (!rateLimit('signup:' + ip)) return c.json({ error: 'Too many requests' }, 429)
  const body = await c.req.json().catch(() => null)
  const parsed = signupSchema.safeParse(body)
  if (!parsed.success) return c.json({ error: 'Invalid payload' }, 400)
  const email = parsed.data.email.toLowerCase()
  const exists = db.query('SELECT 1 FROM users WHERE email = ?').get(email)
  if (exists) return c.json({ error: 'Account exists' }, 409)

  const id = crypto.randomUUID()
  const password_hash = hashPassword(parsed.data.password)
  const created_at = now()
  db.query('INSERT INTO users (id, email, password_hash, created_at) VALUES (?, ?, ?, ?)').run(id, email, password_hash, created_at)

  const token = newSessionToken()
  const token_hash = sha256Hex(token)
  const csrf_secret = randomBytes(32).toString('hex')
  const ua = c.req.header('user-agent') || ''
  const expires_at = now() + SESSION_TTL_MS
  db.query('INSERT INTO sessions (id, user_id, token_hash, csrf_secret, created_at, expires_at, user_agent, ip) VALUES (?, ?, ?, ?, ?, ?, ?, ?)')
    .run(crypto.randomUUID(), id, token_hash, csrf_secret, now(), expires_at, ua, ip)

  setSessionCookie(c, token)
  return c.json({ id, email })
})

app.post('/api/auth/login', async (c) => {
  const ip = c.req.header('x-forwarded-for') || 'local'
  if (!rateLimit('login:' + ip)) return c.json({ error: 'Too many requests' }, 429)
  const body = await c.req.json().catch(() => null)
  const parsed = loginSchema.safeParse(body)
  if (!parsed.success) return c.json({ error: 'Invalid payload' }, 400)
  const email = parsed.data.email.toLowerCase()
  const user = db.query('SELECT id, email, password_hash FROM users WHERE email = ?').get(email)
  if (!user || !verifyPassword(parsed.data.password, user.password_hash)) {
    return c.json({ error: 'Invalid credentials' }, 401)
  }

  const token = newSessionToken()
  const token_hash = sha256Hex(token)
  const csrf_secret = randomBytes(32).toString('hex')
  const ua = c.req.header('user-agent') || ''
  const expires_at = now() + SESSION_TTL_MS
  db.query('INSERT INTO sessions (id, user_id, token_hash, csrf_secret, created_at, expires_at, user_agent, ip) VALUES (?, ?, ?, ?, ?, ?, ?, ?)')
    .run(crypto.randomUUID(), user.id, token_hash, csrf_secret, now(), expires_at, ua, ip)

  setSessionCookie(c, token)
  return c.json({ id: user.id, email: user.email })
})

app.post('/api/auth/logout', (c) => {
  const raw = getCookie(c, SESSION_COOKIE)
  if (raw) {
    const token_hash = sha256Hex(raw)
    db.query('DELETE FROM sessions WHERE token_hash = ?').run(token_hash)
  }
  clearSessionCookie(c)
  return c.json({ ok: true })
})

app.get('/api/me', (c) => {
  const sess = getSession(c)
  if (!sess) return c.json({ error: 'Unauthorized' }, 401)
  return c.json({ id: sess.uid, email: sess.email })
})

// Delete current user account (requires CSRF, session)
app.delete('/api/account', (c) => {
  const sess = getSession(c)
  if (!sess) return c.json({ error: 'Unauthorized' }, 401)
  db.query('DELETE FROM users WHERE id = ?').run(sess.uid)
  clearSessionCookie(c)
  return c.json({ ok: true })
})

// Change current user password (requires current password and CSRF)
app.put('/api/account/password', async (c) => {
  const sess = getSession(c)
  if (!sess) return c.json({ error: 'Unauthorized' }, 401)

  const body = await c.req.json().catch(() => null)
  const current = body?.currentPassword?.toString() || ''
  const nextPwd = body?.newPassword?.toString() || ''
  if (!current || !nextPwd) return c.json({ error: 'Invalid payload' }, 400)
  if (nextPwd.length < 8) return c.json({ error: 'Password too short' }, 400)

  const row = db.query('SELECT password_hash FROM users WHERE id = ?').get(sess.uid)
  if (!row || !verifyPassword(current, row.password_hash)) {
    return c.json({ error: 'Current password incorrect' }, 401)
  }

  const newHash = hashPassword(nextPwd)
  db.query('UPDATE users SET password_hash = ? WHERE id = ?').run(newHash, sess.uid)
  return c.json({ ok: true })
})

// --- routes: Google OAuth --------------------------------------------------
function q(obj) { return new URLSearchParams(obj).toString() }
function cleanupOldOauthStates() {
  const cutoff = now() - (15 * 60_000)
  db.query('DELETE FROM oauth_states WHERE created_at < ?').run(cutoff)
}

app.get('/api/auth/google/start', (c) => {
  if (!GOOGLE_CLIENT_ID || !GOOGLE_CLIENT_SECRET) {
    return c.json({ error: 'Google OAuth not configured. Set GOOGLE_CLIENT_ID/GOOGLE_CLIENT_SECRET.' }, 500)
  }
  cleanupOldOauthStates()

  const state = b64url(randomBytes(24))
  const code_verifier = b64url(randomBytes(64))
  const nonce = b64url(randomBytes(24))
  const created_at = now()
  db.query('INSERT INTO oauth_states (state, code_verifier, nonce, created_at) VALUES (?, ?, ?, ?)')
    .run(state, code_verifier, nonce, created_at)

  const url = 'https://accounts.google.com/o/oauth2/v2/auth?' + q({
    client_id: GOOGLE_CLIENT_ID,
    redirect_uri: OAUTH_REDIRECT_URI,
    response_type: 'code',
    scope: 'openid email profile',
    include_granted_scopes: 'true',
    access_type: 'offline',
    state,
    nonce,
    code_challenge: pkceChallenge(code_verifier),
    code_challenge_method: 'S256',
    prompt: 'consent'
  })
  return c.redirect(url, 302)
})

app.get('/api/auth/google/callback', async (c) => {
  if (!GOOGLE_CLIENT_ID || !GOOGLE_CLIENT_SECRET) {
    return c.text('Google OAuth not configured.', 500)
  }
  const url = new URL(c.req.url)
  const code = url.searchParams.get('code') || ''
  const state = url.searchParams.get('state') || ''
  if (!code || !state) return c.text('Missing code/state', 400)

  const row = db.query('SELECT code_verifier, nonce, created_at FROM oauth_states WHERE state = ?').get(state)
  if (!row) return c.text('Invalid state', 400)
  // single-use
  db.query('DELETE FROM oauth_states WHERE state = ?').run(state)
  if (now() - row.created_at > 15 * 60_000) return c.text('State expired', 400)

  // Exchange code
  const tokenRes = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: q({
      code,
      client_id: GOOGLE_CLIENT_ID,
      client_secret: GOOGLE_CLIENT_SECRET,
      redirect_uri: OAUTH_REDIRECT_URI,
      grant_type: 'authorization_code',
      code_verifier: row.code_verifier
    })
  })
  if (!tokenRes.ok) {
    const t = await tokenRes.text().catch(() => '')
    return c.text('Token exchange failed: ' + t, 400)
  }
  const tokenJson = await tokenRes.json()
  const access_token = tokenJson.access_token
  if (!access_token) return c.text('No access_token', 400)

  // Fetch userinfo
  const uiRes = await fetch('https://openidconnect.googleapis.com/v1/userinfo', {
    headers: { 'Authorization': 'Bearer ' + access_token }
  })
  if (!uiRes.ok) {
    const t = await uiRes.text().catch(() => '')
    return c.text('Userinfo failed: ' + t, 400)
  }
  const userinfo = await uiRes.json()
  const email = (userinfo.email || '').toLowerCase()
  const sub = userinfo.sub
  const emailVerified = !!userinfo.email_verified
  if (!email || !sub || !emailVerified) {
    return c.text('Google did not return a verified email', 400)
  }

  // Find or create user & link oauth account
  let user = db.query('SELECT id, email FROM users WHERE email = ?').get(email)
  if (!user) {
    const id = crypto.randomUUID()
    db.query('INSERT INTO users (id, email, password_hash, created_at) VALUES (?, ?, NULL, ?)').run(id, email, now())
    user = { id, email }
  }
  // Link account if not linked
  const linked = db.query('SELECT 1 FROM oauth_accounts WHERE provider = ? AND provider_user_id = ?').get('google', sub)
  if (!linked) {
    db.query('INSERT INTO oauth_accounts (provider, provider_user_id, user_id, created_at) VALUES (?, ?, ?, ?)')
      .run('google', sub, user.id, now())
  }

  // Create session
  const token = newSessionToken()
  const token_hash = sha256Hex(token)
  const csrf_secret = randomBytes(32).toString('hex')
  const ua = c.req.header('user-agent') || ''
  const ip = c.req.header('x-forwarded-for') || 'local'
  const expires_at = now() + SESSION_TTL_MS
  db.query('INSERT INTO sessions (id, user_id, token_hash, csrf_secret, created_at, expires_at, user_agent, ip) VALUES (?, ?, ?, ?, ?, ?, ?, ?)')
    .run(crypto.randomUUID(), user.id, token_hash, csrf_secret, now(), expires_at, ua, ip)

  setSessionCookie(c, token)

  // Redirect to frontend
  const dest = (process.env.FRONTEND_ORIGIN || 'http://localhost:5173') + '/dashboard'
  return c.redirect(dest, 302)
})

export default app
`.trimStart();
}

function frontendFilesWithAuth() {
  return {
    "src/http.ts": `
type CsrfBundle = { nonce: string; token: string; exp: number }
let csrfCache: CsrfBundle | null = null

async function fetchCsrf(): Promise<CsrfBundle | null> {
  try {
    const res = await fetch('/api/auth/csrf', { credentials: 'include' })
    if (!res.ok) return null
    return await res.json()
  } catch { return null }
}

async function ensureCsrf(): Promise<CsrfBundle | null> {
  const now = Date.now()
  if (csrfCache && csrfCache.exp - 5000 > now) return csrfCache
  const fresh = await fetchCsrf()
  if (fresh) csrfCache = fresh
  return fresh
}

export async function apiFetch<T = any>(
  input: string,
  opts: { method?: string; body?: any; headers?: Record<string, string>; allowNoCsrf?: boolean } = {}
): Promise<Response> {
  const method = (opts.method || 'GET').toUpperCase()
  const headers: Record<string, string> = { ...(opts.headers || {}) }
  let body: BodyInit | undefined = undefined

  if (opts.body !== undefined && !(opts.body instanceof FormData)) {
    headers['Content-Type'] = headers['Content-Type'] || 'application/json'
    body = JSON.stringify(opts.body)
  } else {
    body = opts.body
  }

  const unsafe = !['GET','HEAD','OPTIONS'].includes(method)
  if (unsafe && !opts.allowNoCsrf) {
    const b = await ensureCsrf()
    if (b) {
      headers['X-CSRF-Nonce'] = b.nonce
      headers['X-CSRF-Token'] = b.token
    }
  }

  return fetch(input, { method, headers, body, credentials: 'include' })
}
`.trimStart(),

    "src/components/Navbar.tsx": `
import { Link } from 'react-router-dom'
import { useAuth } from '../auth'
import Avatar from './Avatar'

export default function Navbar() {
  const { user } = useAuth()

  return (
    <nav className="bg-white">
      <div className="max-w-6xl mx-auto px-6 py-4 flex items-center justify-between">
        <Link to="/" className="text-xl font-bold text-gray-900">
          Logo
        </Link>
        
        <div className="flex items-center space-x-4">
          {user ? (
            <>
              <Avatar user={user} />
            </>
          ) : (
            <>
              <Link 
                to="/login"
                className="text-sm text-gray-700 hover:text-gray-900"
              >
                Login
              </Link>
              <Link
                to="/signup"
                className="text-sm bg-black text-white px-3 py-1 rounded hover:bg-gray-800"
              >
                Sign up
              </Link>
            </>
          )}
        </div>
      </div>
    </nav>
  )
}
`.trimStart(),

    "src/components/Modal.tsx": `
import React, { useEffect } from 'react'
import ReactDOM from 'react-dom'

interface ModalProps {
  isOpen: boolean
  onClose: () => void
  title?: string
  children: React.ReactNode
  size?: 'sm' | 'md' | 'lg' | 'xl'
}

const sizeClasses = {
  sm: 'max-w-sm',
  md: 'max-w-md',
  lg: 'max-w-lg',
  xl: 'max-w-2xl'
}

export default function Modal({ isOpen, onClose, title, children, size = 'md' }: ModalProps) {
  // Close on Escape key
  useEffect(() => {
    if (!isOpen) return
    const onKey = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose()
    }
    document.addEventListener('keydown', onKey)
    return () => document.removeEventListener('keydown', onKey)
  }, [isOpen, onClose])

  if (!isOpen) return null

  return ReactDOM.createPortal(
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/50" onClick={onClose} />
      <div className={"relative bg-white rounded-lg shadow-lg w-full " + sizeClasses[size] + " mx-4"}>
        {title && (
          <header className="px-6 py-4 border-b text-lg font-semibold flex justify-between items-center">
            <span>{title}</span>
            <button
              onClick={onClose}
              aria-label="Close"
              className="text-gray-500 hover:text-gray-700 focus:outline-none"
            >
              ×
            </button>
          </header>
        )}
        <div className="px-6 py-4">{children}</div>
      </div>
    </div>,
    document.body
  )
}
`.trimStart(),

    "src/components/Avatar.tsx": `
import { useState, useRef, useEffect } from 'react'
import { useAuth } from '../auth'
import Menu, { type MenuSection } from './Menu'

type User = { id: string; email: string }

interface AvatarProps {
  user: User
}

export default function Avatar({ user }: AvatarProps) {
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const containerRef = useRef<HTMLDivElement>(null)
  const { logout } = useAuth()

  // Close menu when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsMenuOpen(false)
      }
    }

    if (isMenuOpen) {
      document.addEventListener('mousedown', handleClickOutside)
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [isMenuOpen])

  // Get user initials for avatar
  const getInitials = (email: string) => {
    const name = email.split('@')[0]
    return name.slice(0, 2).toUpperCase()
  }

  const handleLogout = async () => {
    await logout()
  }

  const menuSections: MenuSection[] = [
    {
      header: {
        title: user.email,
        subtitle: 'Signed in'
      },
      items: []
    },
    {
      items: [
        {
          type: 'link',
          label: 'Dashboard',
          href: '/dashboard'
        },
        {
          type: 'link',
          label: 'Settings',
          href: '/settings'
        },
      ]
    },
    {
      items: [
        {
          type: 'button',
          label: 'Sign out',
          onClick: handleLogout,
          variant: 'danger'
        }
      ]
    }
  ]

  return (
    <div ref={containerRef} className="relative">
      <button
        onClick={() => setIsMenuOpen(!isMenuOpen)}
        className="w-8 h-8 bg-gray-900 text-white rounded-full flex items-center justify-center text-xs font-medium hover:bg-gray-800 transition-colors"
        aria-label="User menu"
      >
        {getInitials(user.email)}
      </button>

      {isMenuOpen && (
        <Menu 
          sections={menuSections}
          onClose={() => setIsMenuOpen(false)} 
        />
      )}
    </div>
  )
}
`.trimStart(),

    "src/components/Menu.tsx": `
import { forwardRef, ReactNode } from 'react'
import { Link } from 'react-router-dom'

export interface MenuItem {
  type: 'link' | 'button' | 'divider' | 'header'
  label?: string
  href?: string
  onClick?: () => void
  variant?: 'default' | 'danger'
  disabled?: boolean
  icon?: ReactNode
  description?: string
}

export interface MenuSection {
  items: MenuItem[]
  header?: {
    title: string
    subtitle?: string
  }
}

interface MenuProps {
  sections: MenuSection[]
  onClose: () => void
  className?: string
  width?: 'sm' | 'md' | 'lg' | 'xl'
  position?: 'left' | 'right'
}

const widthClasses = {
  sm: 'w-48',
  md: 'w-64', 
  lg: 'w-80',
  xl: 'w-96'
}

const positionClasses = {
  left: 'left-0',
  right: 'right-0'
}

const Menu = forwardRef<HTMLDivElement, MenuProps>(
  ({ sections, onClose, className = '', width = 'md', position = 'right' }, ref) => {
    const handleItemClick = (item: MenuItem) => {
      if (item.onClick) {
        item.onClick()
      }
      onClose()
    }

    const renderItem = (item: MenuItem, index: number) => {
      if (item.type === 'divider') {
        return <div key={index} className="border-t border-gray-100 my-1" />
      }

      if (item.type === 'header') {
        return (
          <div key={index} className="px-4 py-2">
            <div className="text-xs font-semibold text-gray-500 uppercase tracking-wide">
              {item.label}
            </div>
          </div>
        )
      }

      const baseClasses = "flex items-center px-4 py-2 text-sm transition-colors"
      const variantClasses = {
        default: "text-gray-700 hover:bg-gray-100",
        danger: "text-red-600 hover:bg-red-50"
      }
      const disabledClasses = item.disabled ? "opacity-50 cursor-not-allowed" : ""
      
      const itemClasses = \`\${baseClasses} \${variantClasses[item.variant || 'default']} \${disabledClasses}\`

      if (item.type === 'link' && item.href) {
        return (
          <Link
            key={index}
            to={item.href}
            onClick={() => handleItemClick(item)}
            className={itemClasses}
          >
            {item.icon && <span className="mr-3 flex-shrink-0">{item.icon}</span>}
            <div className="flex-1">
              <div>{item.label}</div>
              {item.description && (
                <div className="text-xs text-gray-500 mt-0.5">{item.description}</div>
              )}
            </div>
          </Link>
        )
      }

      return (
        <button
          key={index}
          onClick={() => !item.disabled && handleItemClick(item)}
          className={\`\${itemClasses} w-full text-left\`}
          disabled={item.disabled}
        >
          {item.icon && <span className="mr-3 flex-shrink-0">{item.icon}</span>}
          <div className="flex-1">
            <div>{item.label}</div>
            {item.description && (
              <div className="text-xs text-gray-500 mt-0.5">{item.description}</div>
            )}
          </div>
        </button>
      )
    }

    return (
      <div
        ref={ref}
        className={\`absolute \${positionClasses[position]} top-full mt-2 \${widthClasses[width]} bg-white rounded-lg shadow-lg border border-gray-200 py-2 z-50 \${className}\`}
      >
        {sections.map((section, sectionIndex) => (
          <div key={sectionIndex}>
            {section.header && (
              <div className="px-4 py-3 border-b border-gray-100">
                <div className="text-sm font-medium text-gray-900 truncate">
                  {section.header.title}
                </div>
                {section.header.subtitle && (
                  <div className="text-xs text-gray-500 mt-1">
                    {section.header.subtitle}
                  </div>
                )}
              </div>
            )}
            <div className={section.header ? "" : "py-1"}>
              {section.items.map((item, itemIndex) => renderItem(item, itemIndex))}
            </div>
            {/* Extra divider between sections (skip if section already has header with its own border) */}
            {sectionIndex < sections.length - 1 && !section.header && (
              <div className="border-t border-gray-100 my-1" />
            )}
          </div>
        ))}
      </div>
    )
  }
)

Menu.displayName = 'Menu'

export default Menu
`.trimStart(),

    "src/auth.tsx": `
import React, { createContext, useContext, useEffect, useState } from 'react'
import { apiFetch } from './http'

type User = { id: string; email: string } | null
type AuthContextType = {
  user: User
  refresh: () => Promise<void>
  login: (email: string, password: string) => Promise<boolean>
  signup: (email: string, password: string) => Promise<boolean>
  logout: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | null>(null)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User>(null)

  const refresh = async () => {
    const res = await apiFetch('/api/auth/session')
    setUser(res.ok ? await res.json() : null)
  }

  useEffect(() => { refresh() }, [])

  const login = async (email: string, password: string) => {
    const res = await apiFetch('/api/auth/login', {
      method: 'POST',
      body: { email, password },
      allowNoCsrf: true
    })
    if (res.ok) { await refresh(); return true }
    return false
  }

  const signup = async (email: string, password: string) => {
    const res = await apiFetch('/api/auth/signup', {
      method: 'POST',
      body: { email, password },
      allowNoCsrf: true
    })
    if (res.ok) { await refresh(); return true }
    return false
  }

  const logout = async () => {
    await apiFetch('/api/auth/logout', { method: 'POST' })
    await refresh()
  }

  return (
    <AuthContext.Provider value={{ user, refresh, login, signup, logout }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const ctx = useContext(AuthContext)
  if (!ctx) throw new Error('useAuth must be used within AuthProvider')
  return ctx
}
`.trimStart(),

    "src/pages/Home.tsx": `
export default function Home() {
  return (
    <div className="p-6 max-w-4xl mx-auto">
      <div className="text-center py-12">
        <h1 className="text-4xl font-bold text-gray-900 mb-4">Welcome to Our App</h1>
        <p className="text-lg text-gray-600 mb-8">
          A modern full-stack application built with React, TypeScript, and Tailwind CSS.
        </p>
        <div className="max-w-2xl mx-auto text-gray-600">
          <p className="mb-4">
            This is a production-ready starter with authentication, secure sessions, and a beautiful UI.
            Get started by signing up for an account or logging in if you already have one.
          </p>
        </div>
      </div>
    </div>
  )
}
`.trimStart(),

    "src/pages/Login.tsx": `
import { useState } from 'react'
import { useAuth } from '../auth'
import { useNavigate, Link } from 'react-router-dom'
import { Eye, EyeOff } from 'lucide-react'

export default function Login() {
  const [email, setEmail] = useState(''); const [password, setPassword] = useState('')
  const [error, setError] = useState(''); const nav = useNavigate()
  const { login } = useAuth()
  const [show, setShow] = useState(false)

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    const ok = await login(email, password)
    if (ok) nav('/dashboard'); else setError('Invalid credentials')
  }

  return (
    <div className="flex items-center justify-center min-h-[calc(100vh-80px)] py-12">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h1 className="text-2xl font-bold text-center mb-6">Login to Your Account</h1>
        <form className="space-y-4" onSubmit={onSubmit}>
          <div>
            <input 
              className="border border-gray-300 rounded w-full p-3 focus:outline-none focus:ring-2 focus:ring-black" 
              placeholder="Email" 
              type="email"
              value={email} 
              onChange={e=>setEmail(e.target.value)} 
              required
            />
          </div>
          <div>
            <div className="relative">
              <input
                className="border border-gray-300 rounded w-full p-3 pr-10 focus:outline-none focus:ring-2 focus:ring-black"
                placeholder="Password"
                type={show ? 'text' : 'password'}
                value={password}
                onChange={e => setPassword(e.target.value)}
                required
              />
              <button
                type="button"
                onClick={() => setShow(!show)}
                className="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-gray-700"
                aria-label="Toggle password"
              >
                {show ? <EyeOff size={18} /> : <Eye size={18} />}
              </button>
            </div>
          </div>
          {error && <div className="text-red-600 text-sm text-center">{error}</div>}
          <button className="bg-black text-white px-4 py-3 rounded w-full hover:bg-gray-800 transition-colors">
            Login
          </button>
        </form>

        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">Or continue with</span>
            </div>
          </div>
          <button
            className="mt-4 border border-gray-300 px-4 py-3 rounded w-full hover:bg-gray-50 transition-colors"
            onClick={() => { window.location.href = '/api/auth/google/start' }}
          >
            Continue with Google
          </button>
        </div>

        <p className="mt-6 text-center text-sm text-gray-600">
          Don't have an account?{' '}
          <Link to="/signup" className="text-black font-medium hover:underline">
            Sign up
          </Link>
        </p>
      </div>
    </div>
  )
}
`.trimStart(),

    "src/pages/Signup.tsx": `
import { useState } from 'react'
import { useAuth } from '../auth'
import { useNavigate, Link } from 'react-router-dom'
import { Eye, EyeOff } from 'lucide-react'

export default function Signup() {
  const [email, setEmail] = useState(''); const [password, setPassword] = useState('')
  const [confirmPw, setConfirmPw] = useState('');
  const [error, setError] = useState(''); const nav = useNavigate(); const [showPw,setShowPw]=useState(false); const [showConf,setShowConf]=useState(false)
  const { signup } = useAuth()

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (password !== confirmPw) { setError('Passwords do not match'); return }
    const ok = await signup(email, password)
    if (ok) nav('/dashboard'); else setError('Could not create account')
  }

  return (
    <div className="flex items-center justify-center min-h-[calc(100vh-80px)] py-12">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h1 className="text-2xl font-bold text-center mb-6">Create Your Account</h1>
        <form className="space-y-4" onSubmit={onSubmit}>
          <div>
            <input 
              className="border border-gray-300 rounded w-full p-3 focus:outline-none focus:ring-2 focus:ring-black" 
              placeholder="Email" 
              type="email"
              value={email} 
              onChange={e=>setEmail(e.target.value)} 
              required
            />
          </div>
          <div>
            <div className="relative">
              <input
                className="border border-gray-300 rounded w-full p-3 pr-10 focus:outline-none focus:ring-2 focus:ring-black"
                placeholder="Password (min 8 chars)"
                type={showPw ? 'text':'password'}
                value={password}
                onChange={e=>setPassword(e.target.value)}
                required minLength={8}
              />
              <button type="button" onClick={()=>setShowPw(!showPw)} className="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-gray-700">
                {showPw? <EyeOff size={18}/> : <Eye size={18}/>}
              </button>
            </div>
          </div>
          <div>
            <div className="relative">
              <input
                className="border border-gray-300 rounded w-full p-3 pr-10 focus:outline-none focus:ring-2 focus:ring-black"
                placeholder="Confirm password"
                type={showConf ? 'text':'password'}
                value={confirmPw}
                onChange={e=>setConfirmPw(e.target.value)}
                required minLength={8}
              />
              <button type="button" onClick={()=>setShowConf(!showConf)} className="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-gray-700">
                {showConf? <EyeOff size={18}/> : <Eye size={18}/>}
              </button>
            </div>
          </div>
          {error && <div className="text-red-600 text-sm text-center">{error}</div>}
          <button className="bg-black text-white px-4 py-3 rounded w-full hover:bg-gray-800 transition-colors">
            Create Account
          </button>
        </form>

        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">Or continue with</span>
            </div>
          </div>
          <button
            className="mt-4 border border-gray-300 px-4 py-3 rounded w-full hover:bg-gray-50 transition-colors"
            onClick={() => { window.location.href = '/api/auth/google/start' }}
          >
            Continue with Google
          </button>
        </div>

        <p className="mt-6 text-center text-sm text-gray-600">
          Already have an account?{' '}
          <Link to="/login" className="text-black font-medium hover:underline">
            Login
          </Link>
        </p>
      </div>
    </div>
  )
}
`.trimStart(),

    "src/pages/Dashboard.tsx": `
import { useAuth } from '../auth'
import { Link } from 'react-router-dom'

export default function Dashboard() {
  const { user } = useAuth()
  
  return (
    <div className="p-6 max-w-4xl mx-auto">
      <div className="bg-white rounded-lg shadow-md p-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">Dashboard</h1>
          <p className="text-gray-600">
            Welcome back, <span className="font-medium">{user?.email}</span>
          </p>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          <div className="bg-gray-50 p-6 rounded-lg">
            <h3 className="text-lg font-semibold text-gray-900 mb-2">Account Info</h3>
            <p className="text-sm text-gray-600 mb-2">Email: {user?.email}</p>
            <p className="text-sm text-gray-600">Status: Active</p>
          </div>
          
          <div className="bg-gray-50 p-6 rounded-lg">
            <h3 className="text-lg font-semibold text-gray-900 mb-2">Quick Actions</h3>
            <div className="space-y-2">
              <Link 
                to="/settings"
                className="block w-full text-left text-sm text-blue-600 hover:text-blue-800"
              >
                Account Settings
              </Link>
              <button className="block w-full text-left text-sm text-blue-600 hover:text-blue-800">
                View Reports
              </button>
            </div>
          </div>
          
          <div className="bg-gray-50 p-6 rounded-lg">
            <h3 className="text-lg font-semibold text-gray-900 mb-2">Recent Activity</h3>
            <p className="text-sm text-gray-600">No recent activity to display.</p>
          </div>
        </div>
      </div>
    </div>
  )
}
`.trimStart(),

    "src/pages/AccountSettings.tsx": `
import { useState } from 'react'
import { useAuth } from '../auth'
import { Link } from 'react-router-dom'
import Modal from '../components/Modal'
import { apiFetch } from '../http'

export default function AccountSettings() {
  const { user } = useAuth()
  const [isEditing, setIsEditing] = useState(false)
  const [email, setEmail] = useState(user?.email || '')
  const [currentPassword, setCurrentPassword] = useState('')
  const [newPassword, setNewPassword] = useState('')
  const [confirmPassword, setConfirmPassword] = useState('')
  const [showDeleteModal, setShowDeleteModal] = useState(false)
  const [showCur, setShowCur]=useState(false); const [showNewPw,setShowNewPw]=useState(false); const [showConf,setShowConf]=useState(false)

  const handleSaveProfile = (e: React.FormEvent) => {
    e.preventDefault()
    // TODO: Implement profile update
    console.log('Saving profile:', { email })
    setIsEditing(false)
  }

  const handleChangePassword = async (e: React.FormEvent) => {
    e.preventDefault()
    if (newPassword !== confirmPassword) {
      alert('New passwords do not match')
      return
    }

    try {
      const res = await apiFetch('/api/account/password', {
        method: 'PUT',
        body: { currentPassword, newPassword }
      })
      if (res.ok) {
        alert('Password updated successfully')
        setCurrentPassword('')
        setNewPassword('')
        setConfirmPassword('')
      } else {
        const err = await res.json().catch(() => ({}))
        alert(err.error || 'Failed to update password')
      }
    } catch {
      alert('Network error')
    }
  }

  return (
    <div className="p-6 max-w-4xl mx-auto">
      <div className="mb-6">
        <nav className="text-sm text-gray-500 mb-4">
          <Link to="/dashboard" className="hover:text-gray-700">Dashboard</Link>
          <span className="mx-2">/</span>
          <span>Account Settings</span>
        </nav>
        <h1 className="text-3xl font-bold text-gray-900">Account Settings</h1>
        <p className="text-gray-600 mt-2">Manage your account preferences and security settings.</p>
      </div>

      <div className="space-y-8">
        {/* Profile Section */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-xl font-semibold text-gray-900">Profile Information</h2>
            <button
              onClick={() => setIsEditing(!isEditing)}
              className="text-sm text-blue-600 hover:text-blue-800"
            >
              {isEditing ? 'Cancel' : 'Edit'}
            </button>
          </div>

          <form onSubmit={handleSaveProfile}>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Email Address
                </label>
                {isEditing ? (
                  <input
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="border border-gray-300 rounded w-full p-3 focus:outline-none focus:ring-2 focus:ring-black"
                  />
                ) : (
                  <p className="text-gray-900">{email}</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Account Status
                </label>
                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                  Active
                </span>
              </div>

              {isEditing && (
                <div className="flex space-x-3">
                  <button
                    type="submit"
                    className="bg-black text-white px-4 py-2 rounded hover:bg-gray-800 transition-colors"
                  >
                    Save Changes
                  </button>
                  <button
                    type="button"
                    onClick={() => setIsEditing(false)}
                    className="border border-gray-300 px-4 py-2 rounded hover:bg-gray-50 transition-colors"
                  >
                    Cancel
                  </button>
                </div>
              )}
            </div>
          </form>
        </div>

        {/* Security Section */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold text-gray-900 mb-6">Security</h2>
          
          <form onSubmit={handleChangePassword} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Current Password
              </label>
              <div className="relative">
                <input
                  type={showCur?'text':'password'}
                  value={currentPassword}
                  onChange={(e)=>setCurrentPassword(e.target.value)}
                  className="border border-gray-300 rounded w-full p-3 pr-10 focus:outline-none focus:ring-2 focus:ring-black"
                  placeholder="Enter your current password"
                />
                <button type="button" onClick={()=>setShowCur(!showCur)} className="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-gray-700">
                  {showCur? <EyeOff size={18}/> : <Eye size={18}/>}
                </button>
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                New Password
              </label>
              <div className="relative">
                <input
                  type={showNewPw?'text':'password'}
                  value={newPassword}
                  onChange={(e)=>setNewPassword(e.target.value)}
                  className="border border-gray-300 rounded w-full p-3 pr-10 focus:outline-none focus:ring-2 focus:ring-black"
                  placeholder="Enter new password"
                  minLength={8}
                />
                <button type="button" onClick={()=>setShowNewPw(!showNewPw)} className="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-gray-700">
                  {showNewPw? <EyeOff size={18}/> : <Eye size={18}/>}
                </button>
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Confirm New Password
              </label>
              <div className="relative">
                <input
                  type={showConf?'text':'password'}
                  value={confirmPassword}
                  onChange={(e)=>setConfirmPassword(e.target.value)}
                  className="border border-gray-300 rounded w-full p-3 pr-10 focus:outline-none focus:ring-2 focus:ring-black"
                  placeholder="Confirm new password"
                  minLength={8}
                />
                <button type="button" onClick={()=>setShowConf(!showConf)} className="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-gray-700">
                  {showConf? <EyeOff size={18}/> : <Eye size={18}/>}
                </button>
              </div>
            </div>

            <button
              type="submit"
              disabled={!currentPassword || !newPassword || !confirmPassword}
              className="bg-black text-white px-4 py-2 rounded hover:bg-gray-800 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Change Password
            </button>
          </form>
        </div>

        {/* Danger Zone */}
        <div className="bg-white rounded-lg shadow-md p-6 border-l-4 border-red-500">
          <h2 className="text-xl font-semibold text-red-900 mb-4">Danger Zone</h2>
          <p className="text-gray-600 mb-4">
            Once you delete your account, there is no going back. Please be certain.
          </p>
          <button
            className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition-colors"
            onClick={() => setShowDeleteModal(true)}
          >
            Delete Account
          </button>

          {/* Delete confirmation modal */}
          <Modal
            isOpen={showDeleteModal}
            onClose={() => setShowDeleteModal(false)}
            title="Delete account?"
            size="sm"
          >
            <p className="text-gray-700 mb-6">
              This action cannot be undone. All of your data will be permanently removed.
            </p>
            <div className="flex justify-end space-x-3">
              <button
                className="border border-gray-300 px-4 py-2 rounded hover:bg-gray-50 transition-colors"
                onClick={() => setShowDeleteModal(false)}
              >
                Cancel
              </button>
              <button
                className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition-colors"
                onClick={async () => {
                  try {
                    await apiFetch('/api/account', { method: 'DELETE' })
                  } catch {}
                  window.location.href = '/' // redirect to home (session is gone)
                }}
              >
                Yes, delete
              </button>
            </div>
          </Modal>
        </div>
      </div>
    </div>
  )
}
`.trimStart(),

    "src/App.tsx": `
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { AuthProvider, useAuth } from './auth'
import Navbar from './components/Navbar'
import Home from './pages/Home'
import Login from './pages/Login'
import Signup from './pages/Signup'
import Dashboard from './pages/Dashboard'
import AccountSettings from './pages/AccountSettings'

function Protected({ children }: { children: React.ReactNode }) {
  const { user } = useAuth()
  if (user === null) return <Navigate to="/login" replace />
  return <>{children}</>
}

export default function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <div className="min-h-screen bg-gray-50">
          <Navbar />
          <main>
            <Routes>
              <Route path="/" element={<Home/>} />
              <Route path="/login" element={<Login/>} />
              <Route path="/signup" element={<Signup/>} />
              <Route path="/dashboard" element={<Protected><Dashboard/></Protected>} />
              <Route path="/settings" element={<Protected><AccountSettings/></Protected>} />
              <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
          </main>
        </div>
      </BrowserRouter>
    </AuthProvider>
  )
}
`.trimStart(),
  };
}

// Remove default Vite template CSS once Tailwind is added
async function stripDefaultCss(filePath) {
  try {
    // Read any existing content (ignore errors if file missing)
    const current = await fs.readFile(filePath, "utf8").catch(() => "");
    const tailwindImportRe = /@import\s+["']tailwindcss["'];?/;
    // Re-use existing Tailwind import line if present, otherwise add it
    const importLine = tailwindImportRe.exec(current)?.[0] || '@import "tailwindcss";';
    // Overwrite the file with ONLY the Tailwind import + newline
    await fs.writeFile(filePath, importLine + "\n");
  } catch {
    /* ignore errors */
  }
}

// ------------------------------- main --------------------------------------

async function main() {
  const [, , appNameArg, ...rest] = process.argv;
  const appName = appNameArg || "my-app";
  const withAuth = !rest.includes("--minimal"); // default = auth
  const force = rest.includes("--force");

  // Node version check
  const major = parseInt(process.versions.node.split(".")[0], 10);
  if (Number.isFinite(major) && major < 18) {
    console.error(`❌ Node ${process.version} detected. Please use Node >= 18.`);
    process.exit(1);
  }

  await ensureTool("bun", "--version", "Install Bun: https://bun.sh");

  const root = path.resolve(process.cwd(), appName);
  const frontend = path.join(root, "frontend");
  const backend = path.join(root, "backend");

  if (await exists(root) && !(await dirIsEmpty(root)) && !force) {
    console.error(`❌ Target directory "${root}" is not empty. Use --force to scaffold anyway.`);
    process.exit(1);
  }
  await fs.mkdir(root, { recursive: true });

  // -------- FRONTEND --------
  log("📦 Scaffolding frontend with Vite (React + TS)...");
  run(`npm create vite@latest frontend -- --template react-ts`, { cwd: root });

  log("🔧 Installing Tailwind v4 + Vite plugin in frontend...");
  run(`npm i -D tailwindcss @tailwindcss/vite`, { cwd: frontend });

  // Tailwind wiring (+ proxy if auth)
  const viteCfgPath = await findFile(frontend, [
    "vite.config.ts", "vite.config.js", "vite.config.mts", "vite.config.mjs",
  ]);
  if (viteCfgPath) {
    let cfg = await fs.readFile(viteCfgPath, "utf8");
    cfg = addTailwindToViteConfig(cfg);
    if (withAuth) cfg = addProxyToViteConfig(cfg);
    await fs.writeFile(viteCfgPath, cfg);
  } else {
    log("⚠️  Could not find a Vite config to patch. Please add Tailwind (and proxy if using auth) manually.");
  }

  const cssCandidates = ["src/index.css", "src/main.css", "src/style.css"];
  let cssPath = null;
  for (const c of cssCandidates) { const full = path.join(frontend, c); if (await exists(full)) { cssPath = full; break; } }
  if (!cssPath) cssPath = path.join(frontend, "src", "index.css");
  await prependIfMissing(cssPath, `@import "tailwindcss";\n`, '@import "tailwindcss"');
  await stripDefaultCss(cssPath);

  // Remove App.css since we're using Tailwind
  const appCssPath = path.join(frontend, "src", "App.css");
  if (await exists(appCssPath)) {
    await fs.unlink(appCssPath);
  }

  if (withAuth) {
    log("🧭 Adding React Router + auth pages + CSRF helper + Google button...");
    run(`npm i react-router-dom lucide-react`, { cwd: frontend });
    const files = frontendFilesWithAuth();
    for (const [rel, content] of Object.entries(files)) {
      const full = path.join(frontend, rel);
      await fs.mkdir(path.dirname(full), { recursive: true });
      await fs.writeFile(full, content);
    }
  }

  // -------- BACKEND --------
  log("📦 Scaffolding backend with Bun + Hono...");
  let ok = tryRun(`bun create hono@latest backend --template bun --install --pm bun`, { cwd: root });
  if (!ok) {
    console.warn("bun create failed; falling back to npm create hono...");
    run(`npm create hono@latest backend -- --template bun --install --pm bun`, { cwd: root });
  }

  if (withAuth) {
    log("🔐 Installing backend deps (zod) and writing auth server with CSRF + Google OAuth...");
    run(`bun add zod`, { cwd: backend });
    await fs.writeFile(path.join(backend, "src", "index.ts"), backendIndexWithAuthAndGoogle());
    await writeBackendEnvExample(backend);
  } else {
    await fs.writeFile(path.join(backend, "src", "index.ts"), backendIndexMinimal());
  }

  try { await fs.appendFile(path.join(backend, ".gitignore"), `\n# SQLite database\n/data.sqlite\n`); } catch {}

  await writeClaudeMd(root, withAuth);

  // -------- Done --------
  log("\n✅ Done!");
  log(`\nNext steps:`);
  log(`  cd ${appName}`);
  log(`  # Terminal 1 (API)`);
  log(`  cd backend && bun run dev    # http://localhost:3000`);
  log(`  # Terminal 2 (Web)`);
  log(`  cd ../frontend && npm run dev   # http://localhost:5173`);
  if (withAuth) {
    log(`\nAuth preset enabled. Configure Google in backend/.env then try the “Continue with Google” button on /login.`);
  } else {
    log(`\nMinimal preset (no auth). Use /api/todos and /api/health for examples.`);
  }
  log("");
}

main().catch((err) => { console.error(err); process.exit(1); });
